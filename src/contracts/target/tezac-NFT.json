{
  "transpiled": true,
  "noir_version": "1.0.0-beta.1+dec21f055eaccab1",
  "name": "NFT",
  "functions": [
    {
      "name": "get_private_nfts",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "owner",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "page_index",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "kind": "array",
                "length": 10,
                "type": {
                  "kind": "field"
                }
              },
              {
                "kind": "boolean"
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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mDer3kTzZtWbZN6seiPmzao3p+tfd/TmdL3ujt5YX7zujfXFq95U64vXvbG+eN0b64vXvbG+eN2bZN6semN98bo31heve2N98bo31heve2N98ao3zfridW+sL173xvridW+sL173Jpk3q95YX7zujfXF695YX7zujfXF695YX7zmTXTWF697Y33xujfWF697Y33xujfJvFn1xvridW+sL173xvriVW88QX8T/eRNii+uf9JA0IdkN2kodUEDQb+gaiDguqqBgL+qBgJOqhoIeKZqIOCOqoHgfRNVA8H7G5qGQMBpVcMJOB1OwOlwAk4fMNP2vRp8CqMGn92CBnxO6xrwOa1rwOe0rgGf07oGfE6rGiI+p3UN+JzWNeBzWteAz2ldwwk4HU/A6XgCTkd8Tocgo4aw9F5lxOe0rgGf06qGhM9pXQM+p3UN+JzWNeBzWteAz2ldAz6ndQ34nNY1nIDT6QScTifgtOBzOro6ari8x72gAZ/TugZ8Tusa8Dmta8DntK4Bn9O6BnxO6xrwOa1rwOe0rgGf06qGfAJO5xNwOp+Acfgzba9zWW+lXOctKde/PuM14s+03VkvfGa/V+9+n8fFn2l7nDf4M20P9AaeXQd6A793PdAb+H7hQG+SebPqDfwe/kBvTte/7ujN6XrdHb2xvnjdG+uLV73Bn2l7oDfWF697Y33xujfWF697k8ybVW+sL173xvridW+sL173xvridW+sL171Bn+m7YHeWF+87o31xeveWF+87k0yb1a9sb543Rvri9e9sb543Rvri9e9sb54zZuEP9P2QG+sL173xvridW+sL173Jpk3q95YX7zujfXF695YX7zujfXF695YX7zqDf4s5AO9sb543Rvri9e9sb543Ztk3qx6Y33xujcE/U0b5zr46F5686SBoA/RNODPZL6eLZ401LCgAZ/rMeRJg+QFDfj81TXgc1LXgM8zXQM+d3QN+O+b6Brw39/QNeBzWteAz2lVA/5M5jdoOAGn8Wcyv0HDCTiNP5P52tONGpIs9K34M5nfoAGf07oGfE7rGvA5rWvA57SqAX8m8xs04HNa14DPaV0DPqd1DSfgNP5M5jdoOAGn8Wcye/HTe5UvvvqoAZ/TugZ8Tqsa8Gcyv0EDPqd1Dfic1jXgc1rXgM9pXQM+p3UN+JzWNZyA0/gzmd+g4QScxp/J7LOf3qvMaaFvxZ/J/AYN+JzWNeBzWteAz2ldAz6ndQ34nNY14HNa14DPaV0DPqdVDQRzrXUNJ+A0wZxoXQMBp5sbNZSF3/+QCOYu6xoIOK1qIOC0qoGA06oGAk6rGgg4rWkgmLOrayDgtKqBgNOqhhNwmmAOrK4Bn9OlpEnDN9c/acDntK4Bn9O6BnxO6xrwOa1qIJhtqWt4w2taanpdg3c5jrfxz367srSlq+W2twzPzInOLVxb0/gh43rZr41Xh7J49nH8yilMWkNeuDREN1bx/FfHXS5+8qWYL4u+VPNl0Zdmviz4Im+ZAfeQvnjzZdGXYL4s+hIf1JfQwuiLk9cv9m76qILLdW5iMhO3myhmom6ij5M+8XMTH7Xt3tXER+3RdzXxURv6XU181O7/fSbmadBNnYPFP2rr9y4TkxvfaU5u/iR66xN3MDGZidtNtD5xBxOtT3yDiRJGfSJubqL1iTuYaH3iDiZan7jdxPCobynvauKjvv+8q4m2Y9nBRNux7GBiMhO3m2g7lh1MtB3LDibajuUtJpZxGI20MDfRdiw7mGg7lu0mRtux7GCi7Vh2MNF2LDuYaDuWHUxMZuJ2E63ZfoOJ0Y8mxjj/GUu0ZnsHE63Z3sFEa7a3m5is2d7BRGu2dzDRmu0dTLRmewcTk5m43UT78cAOJtqOZQcTbceyg4m2Y3mLiamMbuT5D6qS7Vi2myi2Y9nBRNux7GCi7Vh2MNF2LDuYmMzE7SbajmX7EQyxHcsOJtqOZQcTbcey3cRszfa3Jg6+LA+VK/E2C6KkOFuzPACtpduNmszv00LHmtixJnWsWealMhBjZYSatqp0rapdq1rHqrwyuklb5btWha5VsWtV6lolXaty16rStap2rep6NnzXs7F8wv/VjMnLB9qbu801bGFhzftf+3n5kKhyn9qxpr1/zfKJN2XN+7M5h9CxJnas6fj+LB/OUNbkjjWlY83ycyC357qVMF/T3r9m+XPEyhrfsSZ0rIkda1LHGu05WFrT8RzEjudg+UNQypr2/jXLH3FR1nTkQerIg9SRB6kjD1JHHqSO5yB1PAep4zlIHc+BvPM5+Ofyt//94cvHH3789MsflxXX//nXbz/9+fHzb1//+uf//X77Pz9++fjp08dfv//9y+effvn5ry+/fP/p80/X//fBff3Pv33O7jufq79Uc/22XzY68TsvJV6rGy6Qkq7/0K7/4IcVNVxXpEstl3r+Hw==",
      "brillig_names": [
        "get_private_nfts"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "364657447181031001": {
            "error_kind": "string",
            "string": "invalid admin"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "admin",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "name",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          },
          {
            "name": "symbol",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "prepare_private_balance_increase",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "random",
        "decompose_hint",
        "field_less_than",
        "lte_hint",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "get_admin",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "10055739771636044368": {
            "error_kind": "string",
            "string": "Function get_admin can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JgACBAEnAAABBIBFJgAABAMmAgEEACYCAgQAHxgAAgABgEQkAAAARSQAAABGLQQAAYBEJwIAAgSARCYCAwQBOg0AAgADJSQAAACbHgIAAQAeAgACADI4AAEAAgADJgIBAQEjAgADAAAAbyQAAADEHgIAAQkmAgIAAQo4AQIDIwIAAwAAAIskAAAA1iYCAQADLgwAAQACLAwCASUnAIAEBHgADQAAAIAEgAMjAIADAAAAwykBAAEF96Hzr6Wt1Mo7AQECJSkBAAEFvh4//z6k9vo7AQECJSkBAAEFi40qC3IiUlA7AQECJS0AGMoYyg==",
      "debug_symbols": "5ZXBbsIwDIbfJece4thxEl5lmlCBgCpVLSpl0oR49yWIBugqqnVll12qpvrs/4+dxiex8avjbllU2/ogFm8nUdbrvC3qKqxO50ysmqIsi93y/rOQ8WH0hT/s8youD23etGIBzCoTvtrEV6NChm1RerHg8PodllJ3sFQ6wQBmgCYic6WJNCfa6gHYYkptUcE9/J4JK2fwbhMczP+h9znqTpDqzmN1B82J5kg88+7QdbAjpJ53h7N6B/noPSrYVyuEir1cAuDXEuxkd+LYKRzpmkyZnbS61zWAn+44BimYEjRFCWlKkBsKQu3wGoQMMNLFkCR1kW9nPcgN0AZtl9qQpOcNMZBuF6Mer4AhHxLxdpyY+/0j+id7PYfVR94U+ar01wG2PVbru3nWfu59b7Ttm3rtN8fGxyF3m28QZ4RyGdLlFwgL1BmaoBF0vgA=",
      "brillig_names": [
        "get_admin"
      ]
    },
    {
      "name": "finalize_transfer_to_private",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "10536464181608181124": {
            "error_kind": "string",
            "string": "transfer not prepared"
          },
          "11859452850824495745": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 60
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5527120278801020911": {
            "error_kind": "string",
            "string": "invalid NFT owner"
          }
        },
        "parameters": [
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hiding_point_slot",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "7Z3djty2DoDfZa/3QhKpv75KcVAkaVossEiKJD3AQZF3P57xWPaONHZtazRLmjfFbCONyU8ci6Qk6p+n3z9//PvP316+/PH1+9Mvv/7z9Pr104cfL1+/dH/98/P56eO3l9fXlz9/m/7vJ3X6j0Z37vD9rw9fTn9///Hh24+nX7Rz5vnp85ffTx+96b7ij5fXz0+/OPPzP89P2qotneyGTm7Lkxxu6RQ2dPKwpdOWJwWzpdOWwY16S6cNTzJq7eA+542VskNjZWxqrLUvtEZEf2mNaF1qHWyhcYD01QGMnjY+C28rCB9S4076hsLrGuRRJ/Juiby2LrV2pxZzwkeIQ+OIgJnwoarwWr0V/vQIA3d/BOj7P6L4o4xWqYGu1WH+EejM8IjuY1wyOm+S0QV/PW6oy+JAEmdqGTc01gHG37tabO5Sa61hBGRjqXVwQ+M4YgGleukdZenLMzYZ6S1l6R1p9o40e0+avUfS0gfK0gcgLb1/59LbQXozcXxP0hfcCjRD44B+dAeN14XWkL4ZjRrbukJToyMOUhht5hvbJIQ1ftr0hDu+d9eGGe737ouxwg1KrLspbrHulri1WHdT3O89nmCGOwruhrgNCu6WuN97iMkLN7z3mJgZbgnia+N2A7puPeoa97tfn2CGW8Kclrjf/QoQPdyprXvb9ITby8ukKW6JKlviDvIyaYpbrLsl7ijW3RS3WHdT3JIRbIgbleRMmuKWjGBL3NoI7pa4JSPYEreRIL4pbskItsQNEubswn1miMJwN0MJSHYzRIky9jMU52o3QyvxwH6G4gbtZvjuz1xRYCh52f0MxbfZzdCLb7OfoaRFdzMM4tvsZyi+zW6GctiwAkOxw70MrRIfez9DFIa7GYqPvZshiG/zLxgaGBmivWYoO6z/DUOv4yCFB9jc+AxcXp6VgWs36ueCzoDLm7YtcCdLEm2Be5kHGwOXQKw2cO+HL9Y+Zl5KkOxBY+CyjNIYuHgpbYFHWaBpDFzcwqbAnVRAaw1c3MK2wKUKWmvg4hY2Bi5uYVvgRtzCxsDFLWwLHGTSbAxcJs3GwGXSbAtcDvJUBx51ulIpmhy47IxtC9yKhTcG3t4t1CEMracbZW4A7/53Gh4X57/au+ESPB9G3tqdbzxzzhxH1eOM6gOK+z1K1SqF9cZtat1np5ZUhYnwbyUqSA8Jo0f15mrGQmOd7rf05u0llCU5FIxvaeXeXHB5RuNqo/F62vz0jCpb65eeEe/+DK+wwjMA029AgbcLzcGk0QOMS2YUwKVfgQ0LZuSShXoX1ZIZaRwvVe1+9Fdm5HWNX5hVI34LC794hEEgnNyT6lwvjn1X4pgadFy6qLb7vHSJ6U1xdjVd955SdrjktPtori2myp0O3JhEYXLNBMROciZiJxkTFDvJmQRhcs2kSi0Vbky8MLlm4rQwyZg4YXLNxItvnzORuThnIj5bxiQecy72ITHx8YpJ0HBEJl2OdGisvcqYsPFP/MhEx58LObeU09bdAlRqbEIp9xdSsjz4t21PAA2bH9qjAIoF7gMIbNzp+wH0Q+MwyccngGx87wcBRLHAnQCtAFwAGJUdWOiQAbRsQsVHARQL3AmQTRDaAqBxGUCHAnAfQLHAfQC55Na00UNqqPs4vqrgtJU0b+1jah3MZD/VBQqTha6VUIJJm8wCmmsogUkmabWlqBEKZFAOaimjxGGyd/ECJYqlTK52H6CQtJRO8qhIDudJck0yRj9LTjI9c5LckrWWSDKePkuOZCUn6b93kmulqELvRKdLXdOlrql6AFrRXPDrRSe51HYWneYiVy86Vf9FK2SSVgcTh8QPAEySt7oo8RjqKBi/+RT1ZI29GndXmGnTnh+TrPqj+HFZ1rkjPxhzpTHnJ/a3yC+d+HSQ8XNMsjd35BfSUcfoc35MUoKP4ufF/hb4hUk9i3z+4LJ4cU9+wxcH6zJ+gcnOqDvy84MQofD7pZmMegy/WPD/aKbECvxQDzIAWjvld9Kze1Gx0VPP6amZbJYGVDCrJ5vxnNfTcIkvFvQELnHokp4k56tedLIZZY1Ulwk70elSJ7s424lOl7oju3qiaR7RPovuya6eaM/FxRjr6EHQ15vnOj25hDoLegY8iJ4HGU82KY4lPY8xnkYdYzwNzX0/6/WkuUlog54HGU8uhQwhYEpFBOszPbkUJ1zU8yDjSTPJUdLTmaSnd7meXJYcF/SkmT7ZoCeXVH5Ix/wgKpvpSTMxs0HPg4wnzZTPgp4Ff8hz2aKwoGc4yHhy2XJy2jydZPBvjkDmjW2XRrk0tl3ElkGJTAZ/HRSDLkFx+cwcD2kpndoDFIDMzQZ1TEtZgMJkDWEdFPBDY4vTvVUXKJrJnoZ1UDBVCLVWuRzKIS0FnRuh5D8fLnesrIPi/OCnWP92Ss4bezdeD+QC5ARRCO4kyCRN9jiCXBKqDyQoNriTIJebZB5HkMvdGfckGAftvNc6J3jIsLEmQS6pxQcSPGSYsYqgTwfTvJ/cEDkQDBKT7CUoNriXoPiDWaoa2BQ8rAqFS2nMilBQMVlxrguFyfJ0VSg0a1feG4rEMTkUSVWXoKBAyaEcckoO6Xy+DdbsSkV1MgrBnQQPOdnXJIhig3sJig3uJMjl2vPHEeRyc809Cc4mlJHN1TWPIyg2uJMgm0tx7kdwPqGMbG7QeRjBY2afKxK0x9yicZtgD0V+mDkU8XsLUMSVLUDhUsa4LhQJvHMoXKqs1ITiaF46d28o8vPJoRxzTXAByiHXBJ1OhfE7q/A5lCPu/nI63TbTQQkZFC5lfutCQYGSQzliQOhMqmLfvT+yw5OOS4mflZaSrkbooOQv2kOmDpagHDJ1sAjliM7bEhTHZEpG5YeLnrADlBoHW2gcjR+ctwgqTBv3UJhMyR7CeHvdEhSv7ODmdx9NDoXJi7YqFC6Zt7pQxFJyKFxWb+tCEUvJoUQmzltdKEyct5pQPJdiVHWhMMm8VYXCpRhVXSgoUHIoTFYIq0Ix4rwVoIjzlkPhcminLhQma8lVoaA4bwUo4ubnUKw4bwUo4uYXoIjzlkORbH4JijhvORQvzlsBijhvOZR4zNknFffuPsZrKEEfMkrWbtjJ5LvkYw6Fzc/Hj1B0nIcCJm0ZBTP5+cBl20EwbIKfqlTYRD81qXDZNVqZCgqVAhU2AVBNKlw2jlamIjNzgQqXraOVqRxzZg7pqmSYXIGYqHDZPFqZCpvYsCYVL7ZSoiK2UqDCpfh8ZSooVApU2CSya1LhUqenMpVjevzzVCKXOvGVqYjHX6DCpVJ8ZSrixRWocKkLUZkKCpUClWPmbReogHhxJSri8ReocKnUXpmKePwFKla8uBIV8fgLVI6Z4wdtE5VJEV8o1tjoloeG1aPTmkiBIQrD3QwP6SHWZcinWsUDGR7So6jLMBzSV63LkM8O5PsxVGiTeujG1nBmaBSfDct3ZOiSHarJ9uaRIcn34Vl0mpuQe9FJxipn0Wlu5+1FR7qik3Sfz6LTvDGlF50udUuXOs1TsGfRaWYKetFJpuXPotOMi3vR6bpfgWQE04tO9w0T6b5haF5ecxJd07xiphed7Htda5J5pl50su91behSN3SpA9lkhgayyQxNs4hXLzpd6jT3L/Sik3V6Nd2wWtMNqzXdsFrTDas13bBa01xc7UWnOyVFulMSl5VknapT6UlxKgB7UZPL1bezanZrDsdQk8km8G4p99K0W6PL1aSZwVivJpNNVQtq0syMrFaTy6b7zi4HNY3J1eRS5wPSzXkQS2qSDfsM3QDE0LxD7Sw6zZvOetHpUqdZ8aEXnWywDTRv4OpFJxtsA83brHrRyeZ/gebNUGfRaR6670UnOyUBzePrveh0pySaB8F70elOSXSXJIHukiTQPJzci053SqKbEQC6GQGgmxEAukuSEOg6AnSXJIHmkmQvOtmXIyqyUxLS3S6LQNbWke6hQqR7qBDpHipES/dn6sj6MOjIhtVI89aAXnS673Wa9fd70clGSUh3BQ/pOr2W7jKYpVmMuxedrCNg6R5vs3SPt1m6x9sszQAvbxrcIEKY7BMr1pjCLiAfvrYLcFNj0OHChMlm7JpMaIakd2YidpIxoVmZ585MxE4yJlyqDldlInaSMeFSFbgqEybHi2oy4VK1tyaTyKQ6flUmMu/kTGTeuWbilNhJzkTmnYwJlyrdNZnQTIftY2L1cCK8+xhzJkfMFTg9fq0pMLHsfjtR6SmTXkt2b82Slu4QY0mz3tFaLfnF3EUtmRQCmNeSX1xc1PIQYxkPMZaRyU2Hs1p6mmezV2vJbnW5pCXNE9+rtTzEWHK5F35By0O8Y+EI86XncuP4vJbIJSZJNydGhVMtnwvKBTsq53IkXAa+HhLL5RdfEQmX0KgeEpqnZe6L5IDpaZvERWtHfkN62nsUJhkTsZOMCb/k034m/FJVFZiInVwzCUrsJGfCLjj/F0xi+lobIWfCL8W2e/k88EvI7WfCL31XgckBt20tMaFZ/fHOTGSLUsaEZtHH+zKhWU3yzkwO6NsvMWGTZqvJROwkY+LlfZIzEd8+Y0L3XvtAt3pOoHv/RaSZXOpFp0ud7iUSkWb2oBedLnWgS53m3puz6DQ31PSi06VO88hTLzrdKYluedRIM2A8i063xmikW2M00r2mPNKNkmKkOiWBUkhXdKoZAVCaLnVN19bJlkcFBUxWojqX5tIUJtv8Lxc6g0ImyeAlNY8xmlyqQS6pyWTlfKqmzdXkUrNxSc1jjCaX+gcLanIpgLCkJpMJBWCoowRW5WrSvDZuvZqHGE1NM/RcryaTCWVBTZoh7Xo1jzGahskO2amasaAmk83RC2pyKYUAMIgArqQmE58WjJ1TE7mM5oKaXLwgHwc1J5vgkppc9lMvqclkS+OCmlyyBx48XNp6nFS0Le7dhG54BygA072bvqgf2qQeuglD3zPkUoDyrgzTV2sV4huGeeugB5sNgAttbRj0swEKY8NkiuU4NoHJTEJybJweKDsovNO4JOg4jg2XrCLLsRF/6r2OjeGSv2U5NvK7ebdjwyVTznJsmCSEaY6NHRa5p9TS2HBZk2A5NvK7ebdjw2XvKMex4bLhleXYMFmyYDk2Et8sj43TST2vcoZctmc/lKHY4W6GXKoiPZKhZ7In5KEMJYbZzTCIz7SbYWRSxfahDCXm3csQuFxS+FCGYoe7GXKp/v5QhigM9zLkk+MOI8Olq6O88sPRgu7jG+BnKFyOFqyDYtIqojdG5VDYRLRroOho56BwObawEkras9lB0fONtVaQ0qmdfi5neMhXkHY4NNY+NyyaVfXuDUUsJYfi2HjjFaFwKcBeF8oxZ/B5KAEFSg6FzQpQRSiRTRq4HhRUbPIYNaGIpRSgyDslh6LFzc+hmEP6KfM5KYRDerTzOSnkswu0Xk4K+Wy/fFhOClFCpdyw7DGTnQtQxFJyKE4c4ByKl1CpAEWylzmUIFFBAYok/3MoEQVKDkUyDRkUq8RSClDknZJD0eLm51CgxjtFh/FgmVHLDMcYVY+lsfSpGGreOh0tM2qkDUoV2gY0Q+OAfgRjvC60hvTNOEk2mBJxAypJARqnjc8QEQXifohiifshVonajw6xyh2Uh4colrgfohdLrADRCcRliCaaBHFya02xcYcjjl5wyIhXuZNViK8hjkK8MnE9WUqzOicu7mpj4lE8irbEnRL3ozVx8VWqE3fpBgMdspnTGXmr1CaOamDXfcxtvMqOLyG+hrgV4o2Ji3fYmDiCEK9M3Jqkn7UqJx6EeFviVmy8MXEnvkpr4hIBNSYuiwzNiYt32Ji45MdbE4+yBtSauET5bYl7JTbemri8x6sT9yYRn9ySnIiLr9KYuBYbb0zcSATUmrisujUmLqtuzYmLP96auPgqjYnLGlB14qATcYBsndPLGlBz4uKrNCYuq27NiYuv0pq4+CqNiXuZOVsTF++wMfEgNt6auHiHjYlH8Q5bExfvsDVx8Q6rEx8r94DLVpaDEhtvTFzLqltr4uKrNCZuxB9vTVxizsbEQWy8NXF5j7c9XRhQYs7WxMUfb01cYs7GxK34KruInyBGW3xReBjqZXmErM+NknA4PKj70qzPjaJm831wQ5+wvk8shtILRcNiuaDSfK/OovWmXm5LL73pWXrTs8ymZ5lNz4JNz4JN44WbnoWb9LJqUy/c1Cts6eXMpl5+7TsG1Y2retVQjjuaQp/V7yVUN65KmH1ODKv76BvFwOb7uPV99Or3bNfHru9jNjzHhPV9boTH8302PAc3POfWdWCDXUdvsj63bsua7bPhObe2JM31uXUV0WyfDc8JG56z6AuU+sT1YxpxQ5/1z+lczfV9bqT85/us/y0Ys/590PmWG/qsf1+bG6mE+T4bnmM36GNxQ58N4+NW2sHP7q//fvj28uHj6+fvXY/TP/795dOPl69fLn/++N9fw798/Pby+vry529/ffv66fPvf3/7/Nvr10+nf3tSl//8Gqx9Dt6dvODTX94/h+C7v85zj3fq2Tt7+vM0VAHdc8DQydDJ8X8=",
      "brillig_names": [
        "finalize_transfer_to_private"
      ]
    },
    {
      "name": "private_get_symbol",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18192277837884173995": {
            "error_kind": "string",
            "string": "Function private_get_symbol can only be called statically"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "AAAAAAAQAAAAAAAAAAAAFAAAAAAAAAAQAAAAAAADKLEBAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAF\nAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAAAAAAAAAAAv3DdhnzusS\n69ELXuuTHRHIL5SazQQfYNBQ2ZcaIiopCOv3SyIoyFj/h6AZly+zcR13vy72NtAzacVOyh3gI1Yn\nWSASLK7bXcHKgkjHiRszGkUN03Ss6mWgpK0D+gM/gi5/WcnXUkqPMgrj6CZGvrGAzFyIA6MCtywQ\nnMZeNYQcCw6XavqRAUJVQGKNStLu9MFFfMKxo0ZIMnwF4uh1YSQCMpVCAZnacAUJ5IG5+kVdRPpn\nFR5Hyha5TFZBg/+k2BUuETggTaJEEDbdPyZbRUb0G/gYqO6jIeS/4OlmRP9wGZx6Inx2nqT1wTud\nXeeuNuA3vsnu3w8/roDmGeg8bWweIqci50hz/Vave5OpdredUh6Rc79ate+WDlDk/waTbwqddZWV\nAGEK0r1JYiji1Q5+kZ6WGBRYCngyywqeQqiREHBEpsthujkiIQ2VI+PwL87M8ltm1yPLB2T+WCzd\nSCsPOMLBX4XkuSvbSlnR1oBPlOLu74qSRvN/9kIUCXryewRWu3AbWwtGO7zwxP5xkFUjk9CVM+Gy\nAEvYTp+KU6iPA4D05rswR3a/1Psi4gmHdBVkgemj+PCR0w2xADptqrQpjDMR/JFw+S3pQLBCqrmQ\n1TxqOyYznNprc9+SCDFBWQewX0CKYShHJZAWuSBK5L83U36xlrBcHZj6UQFqm6y7EzcStmwAsjlU\n4if15psYybGz1lqFExhpvyMHBbZLLo0cRbAbpBxALTtsqpfH0yCHznB2OcD/eYwWJ+VMxyPdYxjP\nfnaQwQdAxjV5eHXC13qTQEQj5o5Xz+NuT0J37qKlABEpAacPI3jiNHGgt8EsOMMMz0XfEODo1VRR\neTFMc30Aph3qx2s3DKT0L3OmZct1qevcWM1L34r35/z/o21bcS5ZeJ8Nnbs/Fa3lOEt4SQ2x2DN5\nxzvkESPev8iMn8jWK3KtwTdDjKDTNxRFpXqWkOZE9YS6+kVBJM8BrVvgsTkBGeJB7rvr/1x9fyDc\nbFrRtq943CBtf3eFPwX95+vTciseHnJ25F2V7N3lXTH+5VqLdToWMq33zUayjJSM/Gv6ENqpy7/a\ntGGe+gygA9l/vbExGVb2Rr2SuhJ3VFUJ730FHLek5wXa5D31LvsCssIf7vxQx39TCBtTgkx9Wybj\n1hD4UwK4yPIFMHfAPqvaC/BgyGkH2dmxkT53IoZ3b1nBHCkP0YO2BrG4gV9iaAa0rYGviV9RAMA9\n78Tusa+HeAkGtzFuj4zcO8bpa8vyy75z42iv7obbkrE7n8Zidfb5bByuJQFs13dbHD5+bQAK47x/\n93KS4rwEovRsljfLoyU7Jhe6P1w0dlPAy9ebjNBnFktRSPE940lxrwctRE9fF5wfeEfPMTMtS4tg\nnxp7KRbj6t4ZoyCgcuuadZ5TUdL1dR9cZlWG0GUFqKcRVsO2toTlaeCCiibOxtHUj12HdRrKAefg\ntQW3XqsB3Mdnk364W7NVz/PwEeQ7LQD4nCpld9cowteEH0ex3Hs+LRFs2McCB/TwpJNHpnuHvR9v\nbPAMUxtkSV1ir0uEgRKbF1bnTPU4MQkCKjeDSyBprl7c7vxvGFKwvUKeeg7uHOp71VlBEVXKqxLn\nmnsOeh7B6Ek9KZgLvtRGbUj/SZcYabjLj0dnJJlWRW+4fP6s+0inLuqe1QtIPTlTlkR68xa5UdQ/\n6ogi04vF8qi4ry2u6KhmiT+kJxpmXRjEAHPIhlQsSpJ0Tv53eYRDAR7IaFUJlshB7aYgX8+NpAS1\ndR0D2x/anLHw0RrHXrUwduMH/NGygrgHviS8wGRwmCkKkoT2MH71TpvaQ0E79a16Uw4616xUjnfI\nJGivsBIs2fdIpZgLHilk091bABOQ81R01SL0o47qEN8K3InEjXW1cWNvW760qAb29FliAjAbauTr\nDrvq3SAzQAZvKBNXSPEZYxw/4H+p1wADTj4nRU75krS/hLl7qnRxLiV4NVHfUMAE7HzR9N2LO2Sm\nbyrEl5tl5WVoxaMbFO0Y92zwzuzLR5jedBrom2ToJY+ER3wbYlZaVZunuziDLgRwag4jrDKjVmkH\n+4cjYhWDsXb1meGS1xGTVANEGej5KQRrKZKTywnFkzcutrPm0bmZInk0L86aiDhJaT/NoiotONbU\nuh5HY6dOzbEcofNGloDCcOVRUVNEWS9ZGI+nZRLbOeiSgmsyYQ7gglHgBfzpF8DV3KAZR3xS9gdT\nMrYSAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAiHerQ5p2bbNb1dKxRyu6k0yTesLb+x+kA/PWEMKfcgkESMo8JwpF7AUBv2AgePk\nbnKoVz+LdViZ7wc5hHPHD2EPy7+dPPQCuqPu2l8Knkm1werJWyZMMC3IVObyLXMw3yg+39qJyUgF\nl/CzRC6XUt751Y/Ckgg2GUJh97Fj/vuvHViqYcZK1SIEPXnEgCIZ5Vuhl1Gt/mw2Mk0/tsLaCYkt\nfBipPD2uWICfqu7GqGp49LO8YfGdbnBpNZu/R+f5Bw=="
    },
    {
      "name": "transfer_in_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "11873158822563704285": {
            "error_kind": "string",
            "string": "Mismatch return note field."
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 17
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954044801249163952": {
            "error_kind": "string",
            "string": "NFT not found when transferring"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "1705275289401561847": {
            "error_kind": "string",
            "string": "Mismatch note header storage slot."
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6869395374906889440": {
            "error_kind": "string",
            "string": "Mismatch note header contract address."
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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4mttdfG1trr4WltdTre2+nJVdbq11Zcv19fa6uJrbXXxtba6nG5t9eUn8+nWVm9crq+qytfa6uJrbXXxtba6+FpbXXytrS6+1laX062tvlxVnW5t9cbliq/L9fUF0Nfa6nK6tdUbT2ZfVZWvtdXF19rq4mttdfG1trr4WltdfK2tLr7WVpfTra2+XFWdbm31xuX6+gLoa2118bW2upxubfXlJ/Pp1lZvXK6vqsrX2uria2118bW2uvhaW118ra0uvtZWl9Otrb5cVZ1ubfXG5fr6AuhrbXXxtba6nG5t9caT2VdV5WttdfG1trr4WltdfK2tLr7WVhdfa6uLr7XV5XRrqy9XVadbW71xub6+APpaW118ra0up1tbffnJfLq11RuX66uq8rW2uvhaW118ra0uvtZWF19rq4uvtdXldGurL1dVp1tbffFys6+11bOvtdWzr7XV8+nWVl98MudBfF2uq6oq+1pbPftaWz37Wls9+1pbPftaWz37Wls9n25t9eWq6nRrqzcuV3xdrqsvgNnX2ur5dGurN57MvqoqX2urZ19rq2dfa6tnX2urZ19rq2dfa6tnX2ur59Otrb5cVZ1ubfXG5br6Aph9ra2efa2tnk+3tvryk/l0a6s3LtdXVeVrbfXsa2317Gtt9exrbfXsa2317Gtt9Xy6tdWXq6rTra3euFxfXwB9ra2efa2tnk+3tnrjyeyrqvK1tnr2tbZ69rW2eva1tnr2tbZ69rW2eva1tno+3drqy1XV6dZWb1yury+AvtZWz77WVs+nW1t9+cl8urXVG5frq6rytbZ69rW2eva1tnr2tbZ69rW2eva1tno+3drqy1XV6dZWX75cX2urZ19rq2dfa6vn062tvvxkPt3a6o3L9VVV+VpbPftaWz37Wls9+1pbPftaWz37Wls9n25t9eWq6nRrqzcuV3xdrq8vgL7WVs+nW1u98WT2VVX5Wls9+1pbPftaWz37Wls9+1pbPftaWz37Wls9n25t9eWq6nRrqzcu19cXQF9rqxdfa6uX062tvvhkLqdbW71xua6qqjKIr8t1VVUVX2urF19rqxdfa6sXX2url9Otrb5cVZ1ubfXG5br6Alh8ra1efK2tXk63tnrjyeyrqvK1tnrxtbZ68bW2evG1tnrxtbZ68bW2evG1tno53drqy1XV6dZWb1yuqy+Axdfa6sXX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",
      "brillig_names": [
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "notify_created_nullifier_oracle_wrapper",
        "get_notes_internal",
        "get_collapse_hints",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_public_keys_and_partial_address",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "random",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "_finish_transfer_to_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7176719043052132708": {
            "error_kind": "string",
            "string": "Function _finish_transfer_to_public can only be called internally"
          }
        },
        "parameters": [
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_finish_transfer_to_public"
      ]
    },
    {
      "name": "owner_of",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9443383425599897888": {
            "error_kind": "string",
            "string": "Function owner_of can only be called statically"
          },
          "9605075991997100073": {
            "error_kind": "string",
            "string": "token does not exist"
          }
        },
        "parameters": [
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "owner_of"
      ]
    },
    {
      "name": "process_log",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8861757336002045335": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 99
          },
          "9862881900111276825": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 35
          }
        },
        "parameters": [
          {
            "name": "log_plaintext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "tx_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "unique_note_hashes_in_tx",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 64,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "first_nullifier_in_tx",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "process_log"
      ]
    },
    {
      "name": "cancel_authwit",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "inner_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7ZfNbuowEIXfxWsWM2N7PMOrXF1VAdIqUhRQgCtdob57HYSdoJqyoK1aKTsP+XTm5PiPnMymXh1fnpruebs3yz8n027X1aHZdrE6GbTn3/a7qhvK/aHqD2aJzLQwdbcZhoFeF+a5aWuz5Dh8BxNxuMBEohlGgBKtTi60BcI7NLKzPjtxblSngCV1JE5e0PmRFimpW7ZJ3CFc0X8XBt2czc1s/JzNzWx4zuZmNuHhbBxogh2SZFjcuYF8dQN9uAFacAm2djK7GEo0YEgTEMdqp4ZKS0dU89rRd/4Jfrl/LPoHdfkFQCdNyvsLEBJOENuMuBZwYU1vIMHaOxtGXN4w4oK7Q1ufYEeT7cIl1wFzMlc2SjCGMfWg/g4MWRmBZQoPkdMc+XdHbufIvztyV4w8XqL5Qotx+o8jZ/RwoRnFf3zUoYx+hCfnqLdnQ/4zDJGkJcCk+uDZyz/LUSxWfdO2zcvT1VcNnD9tivNJCum/EqmH68xfY/mv6ptq1daD0PD02K2TbiwP/3fpSeq867frenPs68HDpP1wzyIvCKNslH4D",
      "brillig_names": [
        "notify_created_nullifier_oracle_wrapper"
      ],
      "verification_key": "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"
    },
    {
      "name": "mint",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6515419266667913063": {
            "error_kind": "string",
            "string": "zero token ID not supported"
          },
          "9296579303138805202": {
            "error_kind": "string",
            "string": "token already exists"
          }
        },
        "parameters": [
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "mint"
      ]
    },
    {
      "name": "transfer_to_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "random",
        "decompose_hint",
        "field_less_than",
        "lte_hint",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "AAAAAAAQAAAAAAAAAAAAFAAAAAAAAAAQAAAAAAADKLEBAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAF\nAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAAAAAAAAAAAHfJp4FzlSq\n5euO65q3Wgd3cdeuP090nveolyKmIkZ6EYfULMfodNIajN+LBl6ppu6w4MJAd2AkMbxNaGKnN4oX\nYU0Q8WIsh9GM3kUAuzGaY8jpR7u7SNSfj3xehvBnKg77iFFBXN8N+y6oPc20TBCc9uftAubOtI+p\nyFHnhasZBVosjIVF+vxB/xvsK4N7mPRh+qzCRWWqBpr5alOG02EZxiPIpvYoTz7d97OfMvQsuFsB\nh035MgvsnTgE1l232wD2Ha6NDDsCnO/zy1Pk3kc44gBFRtougl46sOufLb7ICPYvon/8h25eWDIX\ntCAX1uue0SdyJZmW7m0Ag7d/JhkAW2ItzeseMz5BpZ78A/edUSVcc/JAPkzFRqJmQtUgoQYT6DeI\nXLJQqfFt9GOMWQ1bgYCjXUwXWIy2nQNErfSRAwtmpq0ceJtt6kq4SDz3QPMcLa3BSdIiB8nz00U8\nrO0MWbpPf3YQoTDsVgUV3YTlP62pdb5c0QPt+z8lmUkE+wRWu3AbWwtGO7zwxP5xkFUjk9CVM+Gy\nAEvYTp+KU6iPA4D05rswR3a/1Psi4gmHdBVkgemj+PCR0w2xADptqrQV4xplkgIiJYgmoSbwkUCk\nwXOPvocbK/iQsBALg4nhAgup3zsKuAajmCyLfKrv7t8px0keyvO557vogPZsWU7EI5xHdWEz5MT6\nFHWAEAUyx4v9sW8QaPxxZQHXEk2xmZgnhgbIOdRSzaBV2f7H1tjysfJX1szyqZP97k2Fg+D5yCeV\n5QO1/22fLtf9Z+sAB9naLHFgOVNTjSuPeTZlfJm1A7So5MVXm18PRQL7MSP4paNB9CASPutxBrwd\nMENcBvEiqK5jRLfcyj3wMJ1ZFt5xi0VxMTfBCZ3FJfFu2sH+iCs/CienOOiZMlKXmCowK6x45Ip8\n641EaoLEyX1dhJPxATH/AHZjDX/2WvuzVwpyYA4csbGzrsD35Yec4shG7bYOpTUILfwiFeyzYXX6\nbRWCmOuc5Zc9LO96T5lvTfxSriyTh9207p74qcvDtm8mkudeXk/R1CMw+/0loV3FcSVyLTF5akJF\n5FNcj0TCRcfgHXWWBj0SUbIIIKIBzBHDS1IdkFi9Rw8M8bOVLOJQW6YSFzXDZccx1R1CF4RW6FDu\nuh+9Ta+JySxor+BkDWg9SamHaTPc3ciClvXAvuCxw1cJIoDft1cAbsYhJFSCdvDxfDIY+EuYuKKU\n/Cdtn4lsI68iCwjhLCRVSNrCInMvKrH9MFxpdRgtkDaQWtlBwO+HCC5l2f7/nF4lZRuwBuFH63dX\n0VO5t1GdG1GFyGEoq4VCKjJjctzvK6TY4FlHxnuwYY8YhaqaNFAQdDLo5nAYYx8GvzX5WrHbMdme\nJ7LiGmJ9ZehNR4s4LvjMIprgQyoTAwoln8h9H4iR7nMhZNWukx79w+AJG60/OmAFuMpX00liFqN5\nMmY37nR8gnkDEDM61eMlQhAx7EbgyEGTp5OvKnAgDp3jCDvoTpZidx/IgEOJlp/wD2osUJbiQZjx\ncPGooinSrjhL2gQoX9CEu8uVfIzjye5VwQ+rvU8XSsWkoppmCRmdGMyJYINLBHQf/Iq9/JXEzCAa\nFjd7sNYQ3dNt/rUmp5RWarhy91JzUOy2FDI2jJOjwi32hXIxGI3OMz/EKCPJFJUakG/4+xTrDFFT\nvXBcPW2TZoIIMz8KyjY31pYNHqKi9Ik6k5WmCS9a6LKRBVGXCjscHbmaMRf+5OOim08cVUqhLJDB\n0ipRhp+FcSBnJZMBEwOegpuLUkzeuSILdABQxiRaXWrpgH8hkHC34wxBsLdXG8X9Skz7jJEpWMPe\nFZh//ryRqBbq7l6IMp/g7XFO8l04Z8VseJQm+V/U258LWg0+wuXyswQ61ZJ/de4iTnuLsHbAHZ0V\n5pXbSWKEeS9JPkqiXqcfkP+VfiqqnqJkmE8Vy36rLE9ppdgIpW9NDA38Mhan5E5CXO/xhhn0K38P\n64NkjhGx/g2LxrYMbyELfgcMNa3kSIGrDKvqaUG+P83kxOCBYb55eUgirvuz9goze6h9h6g9zazE\noM4XHHhZWh9tKabU0/r2+NPEerxKFB+Ie4R7pOnE3UdmyENjrl3zHS5vMP7v6YQHcE9iOyIHA5vn\nC1V7bw1NWfsSgKGZWD0KkObVU+S9ZEm1jvUHoQoRhUsNMK6nXa3orpJf7Wy/Be+z4rZbBL3nGjNN\nL+szAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAgZr3b8+QIRDF+XkU4KPLH7hcGzDrlsgwPvdxjjZ09dMCNhL4//NIOFpbr5LKMGL\nIPPvoIPMrQYc8UTEV5EtT5YPy7+dPPQCuqPu2l8Knkm1werJWyZMMC3IVObyLXMw3yg+39qJyUgF\nl/CzRC6XUt751Y/Ckgg2GUJh97Fj/vuvHViqYcZK1SIEPXnEgCIZ5Vuhl1Gt/mw2Mk0/tsLaCYkt\nfBipPD2uWICfqu7GqGp49LO8YfGdbnBpNZu/R+f5Bw=="
    },
    {
      "name": "transfer_to_public",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "11873158822563704285": {
            "error_kind": "string",
            "string": "Mismatch return note field."
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 17
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "1705275289401561847": {
            "error_kind": "string",
            "string": "Mismatch note header storage slot."
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "4718290446670665014": {
            "error_kind": "string",
            "string": "NFT not found when transferring to public"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6869395374906889440": {
            "error_kind": "string",
            "string": "Mismatch note header contract address."
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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WGsTa09iLUasTQhfXfiuwpcTvo2Y65cunUYERKyySOsHGpPTxYjbLMkXsb0i1lXEfopYSBEbKGLlROyYiKUSsUUi1kbEnohYDBGbIPbqxd612MsVe5tir0/sfYm9ILE3IvYKxNq5WEsWa6tirVGsvfUD6g80AEj47sKXFb6d8HVE/Pw6QOsCDQRaL9A8PSJ97+589vh4WJ/9Fl63mVyup0fe2h557j3vG3rFleveeMpIOc/2+F3Y+Tw9+3Pi7i6XnCzn1Tqfl3Tdv37tacLaGtOhHnUe7ZF3kkfemR55F3jkXe6Rd51H3q0eefd45D3skfeER95Cj7yXPPLe9Mh72/l87emTT37+xwmXy3nvOJ99gy8MO6zuwbFy3ifO52kD2lk3XLXW63Led87nyL/33uy1KedeJud975H3g0fejx55P3nk/eyR94vzed8BH/3Re9Z6e8p5v3rk/eaR95/zqZOL8F1yYanyyGvvkdfVyXtj3kczJtV9cKac170kN84eHnk9PfJWK8nN37oeOAd65K3nkVfrwV/CA+fGHnmDPPJGevA31gPnOI+88R55O3nwt6sHzt088nb3yJviwd9MD5yzPPJme+TVe/B3lAfOoz3yjvHIO9WDv/M9cF7gkXehR941Hvxd74HzBo+8Gz3y7vLg7xEPnI965D3mkbfQg79FHjif98h7wSPvTQ/+PvLAudgj72OPvO88+PvRA+dPHnk/e+T948FfRWlunO088io98rqX5uavV2lunL098vp45A0ozc3f+h44N/DI29AjL+HB32APnEM88jbxyBvtwd82Hji39cjbziNvVw/+kh446zzyUh55Uz34298D5wEeeXM88o7y4O9YD5zHeeQd75F3hgd/F3ngvNgj7xKPvOs9+LvJA+fNHnm3eOTd68HfXA+cj3vkzfPIW+TB34seOF/yyHvZI+9tD/4+8cD5qUfeZx55P3rw94sHzl898n7zyFuyOJGDv6pgbpztPfI6eOT1CObmr2cwN85eHnm9PfL6OHn7n9X3xE9qt2jiU67k5H0wofK6O/+dsJuct7KT91vXdkPe2PHGXnLeKh55fcqXfl52Q997Vv64dMcmdXrkre6Rt6ZH3joeeQM98sIeeVGPvIRH3iCPvE098oZ55G3ukbelR95Yj7zxHnmTPfJ29MjbzSMv6ZFX5+S9u8/d71R999TV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",
      "debug_symbols": "7Z3fjvS2kfbvxcc+EMniv72VwAic2BsYMOzAcT7gQ5B73+6ekbrnlao54pSqJdWzB4t5HbGL/LFKqoddrfrPdz/9/Ld//+Ovv/z2v7//67v/+ct/vvv197//+Ocvv/92+dd/vnPh9t/+9c8ff7v+819//vjHn9/9j0vJf//dz7/9dP0z+/9+/93//vLrz9/9T7r8ObvY+5TfL/a+1OliNwxLV1cq71eHwbvG1S6FWqaZkLtf77NbvD7eL8/5fnUpS1eHFMaryQ0frv7h++8cgQ3LJoINyybtnA2FeGdDtcHGO5/GuTiKX2STwYZlU8CGZVO/zIaGOl5Mzpfp4kJXA37Y2oD7sgEXBhovDuFhd11eunpwedyAy981PE5oyXVKrZPv1Pn8/cHnv5zpuOrGUZe/fWqsYMj3qx3dvTS+2SAFG1HBRlKwkRkbafIRP7jc8qhyn1Ko6X4PS3Xp8hrrMF5eU8zPLy+pjg5YcgiN+12h6X5XKFPj6hDHi8k/3O3SomdP9xUfhvj8Yhecv8eYa1w83OkNqTxefN2hgh3a+Q5V7NC+dygM2KFP7lCe1ug/TGMRer6nBrnGL+2Qww7tfIe8yA7VSRo5Gh6mv7xDlMv06VR8bV2e/P3y9KB2lnPVnKe7UQktmWZ9+wO23/L2E7bf8vbHI2x/jPftL42DijBNhR5UsSN/W246wnLr/aguB3q+3MtR4XA/NkwPx4xv5zIhm1txOd2Kc77ns7k8zP19xdXaiml48YrjMKTnl+c4fnZ++Kag3O665HY//eL9/UH3OH08cL/0wKVXq61PbL1zy1t/nf4r1EK8fHt2nz6Vx8uvc6JXzCmkySUiucYRw8X+MMXI4Ft3S+sxErGh59rQhA0914a+QlVE8uG+oQ/HAIuXp8uj4v3q5ErjzMA9nC+X9JDCxHBbbtn/cn0Z3Tf5WhtHJI0v86naWm9clhN+uB88+CHFx/VeRy1n8d65Kcy8e8iHma/x74U5zoUHz1uGlO73qOnasJxon+2mEz14q/IOErxdmUo//UNQM7wv/3nandT8aDfdjtzD98iXA6Lb9OnY04+fmH6Mz2344MeHoA/5o4351Zckaaqw84+xcZnddUZpdzPKu5tR2d2M6t5mlIbdzcjtbkZ+dzMKu5sR7W5Gu7tnp93ds9Pu7tlpd/fstLt7dt7dPTvv7p6dd3fPzru7Z+fd3bPz7u7ZeXf37Ly7e3be3T077+6eXXZ3zy67u2eX3d2zy+7u2WV39+yyu3t22d09u+zunl12d88uL7hnhzId/NLDLxNuJ4Czq2Mp4zcQsYahcXWN49F2zffD3OuXX5e11sHQWp2htXpDaw2G1kqG1hoNrTUZWms2tNZiaK2G8iY3GEqc3GAoc3KDodTJDYZyJzeQpcUayp7cYCh9coOh/MkNhhIoN1jKoJylDMpZyqCcpQzKWcqgnKUMylnKoJylDMpZyqCcpQzKWcqgvKUMylvKoLylDMqfLIOaPvpyBlM/rHZ+sYv5/vPGh5cYTWwIbFg2J8vPRNmcLJ0TZXOy7E+UzcmSRVE2J8stJdmEk6WiomxOlrmKsjlZoivKBnkxz4bAhmWDvJhng7yYZ4O8mGeDvJhng7yYZUPIi3k2yIt5NsiLeTbIi3k2BDYsG+TFPBvkxTwb5MU8G+TFPBvkxSybiLyYZ4O8mGeDvJhng7yYZ0Ngw7JBXsyzQV7Ms0FezLNBXsyzQV7MsknIi3k2yIt5NsiLeTbIi3k2BDYsG+TFPBvkxTwb5MU8G+TFPBvkxSybjLyYZ4O8mGeDvJhng7yYZ0Ngw7JBXsyzQV7Ms0FezLNBXsyzQV7MsinIi3k2yIt5NsiLeTbIi3k2BDYsG+TFPBvkxTwb5MU8G+TFPBvkxSybs/U1EmWDvJhng7yYZ4O8mGdDYMOyQV7Ms0FezLNBXsyzQV7Ms0FezLHxZ2tbJcoGeTHPBnkxzwZ5Mc+GwIZlg7yYZ4O8mGeDvJhng7yYZ4O8mGVztmZkomyQF/NskBfzbJAX82wIbFg2yIt5NsiLeTbIi3k2yIt5Npbz4uTGj3Yp5Bmbs7WYW8PmEjQ0TtvTAhvDebGn4sZpx2GYszGcFzfZGM6Lm2wIbFg2hvNin4bxGe6TK3M2hvPiJhvDeXGTjeG8uMnGcF7cYmO5353PYWKTo5uzsZwXt9hYzotbbCznxS02BDYsG8t5cYuN5by4xcZyXtxiYzkv/sCmNK7Oabw45zRde0F6w2g6hS51wpjmxxmWW+M12VhOoVtsLKfQLTaWU+gWGwIblo3hFDpQHD86RDf/ms9ya7wmG8MpdJON5RS68VWW5dZ4LTaWW+M12ZjOi59/JWG5NV6Tjem8uMGGwIZlg5ILng2OltnjU8ut8ZpscLTMs7GcFzfYWG6N12SDkgueDUoueDYoueDZENj89PWvQC130Wsdu1vuotdkY7pqucHGcAodhurHY3cX4pyN4RS6xcZyF70mG8MpdJON4RS6ycZwCt1kQ2DDsrGcF8e7vIi5dTW5WsZp+4cv2vMbR5Rn3HxsqQTBcse9JhvLOXSLDcoz3u5NCyUIljvuNdngjRg8G7wRg2eD8ozbtJe+Zrfcca/JBuUZPBu8EYNngzdi8GxQnvF27r7wlaDljnstNpY77jXZoDyDZ4PyDJ4NyjN4NgQ2LBu8EYNng7LldzZfKuux3JyvVZ5huTlfkw3eiMGxCZab8zXZ4I0YPBuUZ1yvXvqaPVhuztdkQ2DDsrH8RowWG8slFy02lksuWmxQtsyzQdkyy8Zyc74mG8t5sVwZYbDcyE+Uo+V8+3lZXbDc9K/JBm+g49lYPrJ+XjoWLDf9a7LBG+h4NihxZtmYbvr3vDwqmG7612KDN9DxbFDizLMhsGHZoJTjNu2FUo5guulfiw3eQMezQYkzzwYlziwbNP17wgYlzjwblDjzbFDi/M7mK+WYwXR/wEZ5lOn+gC02eAMdzwYlzjwblDjzbFDKcb16sVzBctO/Jhu8gY5ngxJnng1KnHk2BDYsG5Q482xQ4syzQYkzz8ZyXixYRmi6QaAgR8vNBFtldZabCTbZWM63W2wsH1k3SsdMNxNssbF8Dt1igxJnng3eVneb9lJ5lOlmgi02pl+18ZyN6WaCLTYocebZoJTjNu2lUg40E3zChsCGZYMSZ54NSpx5Nihx5tmgxJlngxJnlo3lDoGC5ZiWmwm2yqMsNxNssjH9K8EGGwIblg1KnHk2KOW4Xr1YrmC6QWCLDd5Wx7NBiTPLxnKDwCYblDjzbFDizLNBiTPPhsCGZYMm27dpf7WM0HQzQUmOaMh9i9WlsjrLjQebbCzn2w02phsPNkrHTDcebLFBQ26eDUqceTaE8qifmPIo040HW2zQkJtngxJnng1KnHk2KOW4TXuhlINMdxNsscHb6ng2KHHm2aDEmWdDYMOyQYkzzwYlzjwblDi/s/lKOSZZbjzYKI8iy40HW2wsNx5sskGJM88GJc48G5RyXK9eKlcg0w0CW2zwtjqeDUqceTYocebZoMSZZ4MSZ5aN5QaBTTYocebZoMn2bdpfLCMk080EJTkSyup+Wi6rI8uNB5tsLOfbLTZoyP12b5qXjpHpxoMtNmjIzbIx3XiwxQZvq7tNe6E8ikw3HmyxQUNung2BDcsGJc48G5Ry3Ka9VMphuptgiw3eVsezQYkzy8ZyN8EmG5Q482xQ4syzQYkzz4bA5o3Nl8oxLTcebJVHWW482GSDhtw8G5Q482xQ4syyMd0gsFGuYLpBYIsN3lbHs0GJM8+GwIZlgxJnng1KnHk2KHHm2aDEmWeDJtu3aX+1jNB0M0FJjmjIfYvVpbI6y40Hm2ws59stNoTSsZ+Y0jHTjQdbbNCQm2eDEmeeDd5Wd5v2UnmU6caDDTamGw+22KDEmWeDEmeeDUo5btNeKuUw3U2wxQZvq+PZoMSZZ4MSZ54NSpx5NihxZtlY7ibYZIMS53c2XyrHtNx4sFUeZbnxYJMNgQ3LBiXOPBuUOPNsUMpxvXqxXMF0g8AWG7ytjmVjuUFgkw1KnHk2KHHm2aDEmWdDYMOyQYkzzwZNtm/T/moZoelmgpIc0ZD7FqtLZXWWGw822ETLjQebbNCQ++3eNC8di6YbD7bYoCE3z4bAhmWDt9Xdpr1QHhVNNx5ssUFDbp4NSpx5NihxZtmY7ib4vJQjmu4m2GKDt9XxbFDizLMhsGHZoMSZZ4MSZ54NSpx5NihxfmfzlXLMaLnxYKM8KlpuPNhkg4bcPBuUOPNsUOLMsyGUK/y0XK4QTTcIbLHB2+p4Nihx5tmgxJlngxJnlo3lBoFNNihx5tmgxJlngybbt2l/sYwwmm4mKMkRDblvsbpUVme58WCTjeV8u8UGDbnf7k0LpWOmGw822JhuPNhigxJnng3eVneb9lJ5lOnGgy02BDYsG5Q482xQ4syzQSnHbdpLpRymuwm22OBtdSwby90Em2xQ4syzQYkzzwYlzjwbAhuWDUqc39l8qRzTcuPBVnmU5caDTTZoyM2zQYkzy8Z0M8EWG5RyXK9eLFcw3SCwxQZvq+PZENiwbFDizLNBiTPPBiXOPBuUOPNsUOLMsjHdIFCwjNB0M0FJjmjIfYvVpbI6y40Hm2wIbFg2aMj9dm9aKB0z3XiwxQYNuXk2KHHm2eBtdbdpL5VHmW482GKDhtw8G5Q482xQ4syzIZQr/MSUcpjuJthig7fV8WxQ4syzQYkzzwYlziwby90Em2xQ4syzQYnzO5svlWNabjzYKo+y3HiwyQYNuXk2KHHm2aDEmWeDUo7r1YvlCqYbBD5nk0w3CGyxQYkzzwYlzjwblDjzbAhsWDYocebZoMSZZ4Mm27dpf7GMMJluJijJEQ25b7G6UFaXLDcebLKxnG+32KAh99u9aV46lkw3HmyxIbBh2aDEmWeDt9Xdpr1QHpVMNx5ssUFDbp4NSpxZNra7CTbYoJTjNu2FUo5kuptgiw3eVsezIbBh2aDEmWeDEmeeDUqceTYocebZoMT5nc1XyjGT5caDjfKoZLnxYJMNGnLzbFDizLMhsGHZoJTjevViuYLpBoEtNnhbHc8GJc48G5Q4s2wsNwhsskGJM88GJc48G5Q482wIZYQ/CZQRmm4mKMkRDblvsbpUVme58WCTjeV8u8UGDbnf7k0LpWOmGw+22KAhN88GJc48G7yt7jbtpfIo040HW2zQkJtngxJnng1KnHk2KOW4TXuplMN0N8EGG9PdBFtsUOLMs0GJM88GJc48GwIblg1KnHk2KHF+Z/OlckzLjQdb5VGWGw822aAhN8vGdOPBFhuUOPNsUMpxvXqxXMF0g8AWGwIblg1KnHk2KHHm2aDEmWeDEmeeDUqcWTaWGwQ22aDJ9m3aXy0jNN1MUJIjGnLfYnWprM5y48EmG8v5dosNGnK/3ZsWSsdMNx5ssUFDbp4NSpxZNqYbDzbKo0w3HmyxQUNung1KnHk2BDYsG5Ry3Ka9VMphuptgiw3eVsezQYkzzwYlzhybbLmbYJMNSpx5Nihx5tmgxPmdzVfKMfNAKI/6abk8KltuPNhkg4bcPBuUOPNsUOLMs0Epx/XqpXKFbLpBYIsN3lbHs0GJM88GJc48GwIblg1KnHk2KHHm2aDEmWeDJtu3aX+xjDCbbiYoyNFy48FGWV223HiwycZyvt1ig4bcb/emeelYNt14sMUGDbl5Nihx5tngbXW3aS+UR2XTjQdbbNCQm2Vju5tggw1KnHk2KOW4TXuplMN0N8EWGwIblg1KnHk2KHHm2aDEmWeDEmeeDUqcWTaWuwkKlmNabjzYKo+y3HiwyQYNuXk2BDYsG5Q482xQynG9erFcwXSDwBYbvK2OZ4MSZ5aN5QaBTTYocebZoMSZZ4MSZ54NgQ3LBk22b9P+ahmh6WaCkhzRkPsWq0tldZYbDzbZWM63G2xMNx5slI6ZbjzYYoOG3DwblDjzbAjlUT8x5VGmGw+22KAhN88GJc48G5Q482xQynGb9lIph+lugi02eFsdzwYlzjwblDjzbAhsWDYocebZoMSZZ4MS53c2XyrHtNx4sFUeZbnxYIuN5caDTTYocebZoMSZZ4NSjuvVi+UKphsEttjgbXU8G5Q482xQ4syzQYkzzwYlziwbyw0CW+UolhsENtngrXI8m73nxSkker86heo/XH1bAO19AcmPV6eUQ+Nql2Ie550HN1/u3vPRlcvND8td2t29p5jCy9171phSGRdwWW3rTuXvD3R/WXoLzpCmVTrXQpnqMNZLpfp4Y6sLFxdP402k+OQfL75h33tCelLse891T4m97L6f4Emx7z1DPyn2vSf/J8W+e11xTuwE7K/Avn9Vdkrs+1eHp8QOlfoS7FCpL8EOlfoK7Ltv2XlS7FCpL8EOlfoS7FCpL8FOwP4K7FCpL8EOlfoS7FCpL8EOlfoS7FCpr8C++0a3J8UOlfoS7FCpL8EOlfoS7ATsr8AOlfoS7FCpL8EOlfoS7FCpL8EOlfoK7LtvO31S7FCpL8EOlfoS7FCpL8FOwP4K7FCpL8EOlfoS7FCpL8EOlfoS7FCpr8C++ybwJ8UOlfpZ7NnT2GUt++vKviEJ4SlFElpSiiSB5KdJ1vEVojm4OUkoPimSEHFSJKHLpEhCakmRhHoSIhkhiKRIQuMI5ZMRGkeKJDSOFEkCSSGS0DhSJKFxpJ7d0DhSJKFxpEhC4wiRTNA4UiShcaRIQuNIkYTG+TRJV8dGDZc/04wkgaQQSWgcIY2ToHGkSELjSJGExpEiCY0jRDJD4wjlkxkaR4okNI4USWgcKZIEkkIkoXGkSELjSJGExpEiCY0jRRIaR+hUrUDjCKnFAo0jRRIaR4okNI4USQJJIZLQOEJZUIHGkSIJjSNFEhpHiiQ0jhDJCo0jRRIaR4okNI4USWgcKZIEkjKnahUaR0gtVmgcKZLQOFIkoXGkSELjyJCsAzSOTBZUB2gcKZLQOFIkoXGkSBJICpGExpEiCY0jRRIaR4okNI4USWgcmVO16qBxhNSig8aRIgmNI0USGkeKJIGkEEloHKEsyEHjSJGExpEiCY0jRRIaR4ikh8aRIgmNI0USGkeKJDSOFEkCSZlTNQ+NI6QWPTSOFEloHCmS0DhSJKFxhEgGaByhLChA40iRhMaRIgmNI0WSQFKIJDSOFEloHCmS0DhSJKFxpEhC4widqhE0jpBaJGgcKZLQOFIkoXGkSBJICpGExhHKgggaR4okNI4USWgcKZLQOEIkIzSOFEloHCmS0DhSJKFxpEgSSMqcqkVoHCG1GKFxpEhC40iRhMaRIgmNI0QyQeMIZUEJGkeKJDSOFEloHCmSBJJCJKFxpEhC40iRhMaRIgmNI0USGkfoVC1D4wipxQyNI0USGkeKJDSOFEkCSSGS0DhCWVCGxpEiCY0jRRIaR4okNI4QyQKNI0USGkeKJDSOFEloHCmSBJIyp2oFGkdILRZoHCmS0DhSJKFxpEhC4wiRrNA4QllQhcaRIgmNI0USGkeKJIGkEEloHCmS0DhSJKFxpEhC40iRhMaROVVzwwCRIyMXLyihcsRQQuaIoYTOEUNJQCmFEkpHJhe6oITUEUMJrSOGEmJHDCXUjhRKB7UjhhJqRwwl1I4YSqgdMZQElEKHbA5qR0o4OqgdMZRQO2IooXbEUELtSKH0UDtSyZCH2hFDCbUjhhJqRwwlAaUUSqgdMZRQO2IooXbEUELtiKGE2pE6ZAtQO1LCMUDtiKGE2hFDCbUjhpKAUgol1I5UMhSgdsRQQu2IoYTaEUMJtSOFkqB2xFBC7YihhNoRQwm1I4aSgFLokI2gdqSEI0HtiKGE2hFDCbUjhhJqRwplhNqRSoYi1I4YSqgdMZRQO2IoCSilUELtiKGE2hFDCbUjhhJqRwwl1I7UIVuC2pESjglqRwwl1I4YSqgdMZQElFIooXakkqEEtSOGEmpHDCXUjhhKqB0plBlqRwwl1I4YSqgdMZRQO2IoCSiFDtky1I6UcMxQO2IooXbEUELtiKGE2pFCWaB2pJKhArUjhhJqRwwl1I4YSgJKKZRQO2IooXbEUELtiKGE2hFDCbUjdchWoXakhGOF2hFDCbUjhhJqRwwlAaUUSqgdqWSoQu2IoYTaEUMJtSOGEmpHCKUboHbEUELtiKGE2hFDCbUjhpKAUuaQzQ1QO0LC8fJhQCmFEmpHDCXUjhhKqB0plA5qRyoZclA7YiihdsRQQu2IoSSglEIJtSOGEmpHDCXUjhhKqB0xlFA7UodsHmpHSjh6qB0xlFA7YiihdsRQElBKoYTakUqGPNSOGEqoHTGUUDtiKKF2pFAGqB0xlFA7YiihdsRQQu2IoSSgFDpkC1A7UsIxQO2IoYTaEUMJtSOGEmpHCiVB7UglQwS1I4YSakcMJdSOGEoCSimUUDtiKKF2xFBC7YihhNoRQwm1I3XIFqF2pIRjhNoRQwm1I4YSakcMJQGlFEqoHalkKELtiKGE2hFDCbUjhhJqRwplgtoRQwm1I4YSakcMJdSOGEoCSqFDtgS1IyUcE9SOGEqoHTGUUDtiKKF2pFBmqB2pZChD7YihhNoRQwm1I4aSgFIKJdSOGEqoHTGUUDtiKKF2xFBC7UgdshWoHSnhWKB2xFBC7YihhNoRQ0lAKYUSakcqGSpQO2IooXbEUELtiKGE2pFCWaF2xFBC7YihhNoRQwm1I4aSgFLokK1C7UgJxwq1I4YSakcMJdSOGEqoHSGUfoDaEUqG/AC1I4YSakcMJdSOGEoCSimUUDtiKKF2xFBC7YihhNoRQwm1I3TI5h3UjpRwdFA7YiihdsRQQu2IoSSglEIJtSOVDDmoHTGUUDtiKKF2xFBC7Uih9FA7YiihdsRQQu2IoYTaEUNJQCl0yOahdqSEo4faEUMJtSOGEmpHDCXUjhTKALUjlQwFqB0xlFA7YiihdsRQElBKoYTaEUMJtSOGEmpHDCXUjhhKqB2pQzaC2pESjgS1I4YSakcMJdSOGEoCSimUUDtSyRBB7YihhNoRQwm1I4YSakcKZYTaEUMJtSOGEmpHDCXUjhhKAkqhQ7YItSMlHCPUjhhKqB0xlFA7YiihdqRQJqgdqWQoQe2IoYTaEUMJtSOGkoBSCiXUjhhKqB0xlFA7YiihdsRQQu1IHbJlqB0p4ZihdsRQQu2IoYTaEUNJQCmFEmpHKhnKUDtiyRDUjliAQ+2IoYTakUJZoHbEUELtiKGE2pFKhgrUjlQyVAgopQIcakcMJdSOGEqoHTGUUDtiKKF2pJKhCrUjhhJqRwwl1I4YSqidT6MkP6kd8nmOkoBSCuXJ1I4fxs/2PreuJj9NJPgHNMPCtTUUer+40vAB5MIHD8N4MQ3u4aPLwsUh5vHiEMvwePHbFp1MRZ1xi06mzs64RSdTfWfcopOpySNuUc5h3KJc6dstCsPJVOoZt+hk6veMW3QyVX3ELSpu2qLiS+NiN6EOLjQ+2ZMfzwE8UZpv/snOAbD5Hza/jgfmPnr3/OI43SVird8q8zAQ/AR+8gk/wQkO/OQzfoJjpBP7SSSa/CTlL/kJzrLgJ5/xExyondhPUpxopOLnIgZHdXY33+EQ0PDm43jxxJufJ3a++PT8YleGsbTAFR/mnoJTTnjK5zwFR6LwlLc9r9GNW14zfUWfOIJTwamknQqHrXAqcafCySyc6t2p6jgNP7j0JafCMS6cStypcOZ7MKeaDnMuT5nGxa3CFYcz3zNvvtgXzR7Hw/CTz/gJTpJP7CdyXzR7nCPDTz7jJzhFPrGfNL6W9ITNt7v5OJU1vPk4PT3x5kt+zexxJApP+Zyn4JwTnvK253Jf83mcn8KppJ0q4LAVTiXuVDiZhVO9O5XYd8cBx7hwKnGnwpnvsZzKh+kVUL513N9SaYGw+XY3H2e+J958wVwWx8Pwk8/4CQ6H4Sef8RMcDZ/ZT+SUCU574Sef8BPCAe7r/aSMhe+hDtQ6FhF8FyThoPXMmy9WKk04O4WffMZPcBwKP/mMnxD85Lx+IldSTzhkhZ98xk9wyHpiP2kUYBNOTg1vPo5DDW8+zjhPvPmSBfURp5zwlM95Co5E4Slvey73pW3E+SmcStypcNgKpxJ3KoJTwanenEqsxiDiGBdOJe5UOPM9mFMJvgsy4sz3zJsv9kVzxPEw/OQzfoKT5BP7idwXzQnnyPCTz/gJTpFP7CeNryUTTnsNbz5OZQ1vPmHzz7v5kl8zJxyJwlM+5yk454SnvO253Nd8CeencCpxp8JhK5xK3KlwMgunencqse+OM45x4VTiToUz32M5leTrADPOfA1vPs58T7z5crlsJvgJ/OQTfoLDYfjJZ/wER8Nn9hM5ZYLTXvjJZ/zEzgHu23p3f7ZY/fisSDW5xtVuuM97CA+nJCEvzsSPE0kPS0yL/lhH/RPCwwf7d45l98dpO+FIw/RCWHrgMXHc/QnSQfxx94cxB/HH3Z9rHMQfCRxF/HH3uvgg/rh73XgQf9y9rtoJx5zGtP36Tvz7B+d3jrvXHes4+jBM8yb/gePbek+mO1rrrSfTB831niyPJ5rmHYfUuC/4MK3SP564+Lz02eVi//3qkkNoXX0/zCn0cHa6fHWYigbI39W/X7pDXT5g+r35h2ksXexynnjkGhsXD9Mnu+GhdOFy8ZuvnEyrhOmcy0WXW75yr+vw/qFDCnxl2VdOpsfgKxv6CiE3/VRuWujepOlx0uOzHJpThuPeNWd2aVzAJWhL4+pa4yhp6uO3uIUWv4godboN+Ppw87pc/kZn70rytXT2rg9fS2fvavKVdC5f0oLOEzr4xkni6UaDhIoLQ7y/dm8YGhz9hfVEfXj4Mt8vrdWVu4YvKczOLC4nnYdfAR1+BXH3K3DuvgJaWEHa+Qr8cL/aOWppTpxlrdCcNGTsvuHdL3vffefjtPvF4bxJdPermd2/rdcNxtbr9NcbgpvWG0NjvXVabo3+eTbvQhhfHHotFrt/sBsX6y0tNlhaLFlabLS02HSixd7zA0c5f1jswqTDvUwpuPtzwUdaXKL30xLp4U5f847zmsvp1f3R10pVgvOTqwT3tbzGZbgV3ErerQrcCm4l71YVbgW3EncrP8Ct4FbybnWmMwW41W7c6kynN3Cr3bjVmc7J4Fa7cSuCW8Gt5N3qTGe/cKvduBVO2eFWG7gVTtnhVhu4FU7Z4VYbuBVO2eFW8m4VcMoOt9rArXDKfmK3elnBb8ApO9xqA7cyfMp+n3R0ruFWcBSCo8BRPuModk/CY5omnR5eOr7sKJ5o2iEqH37jvHSxv19MH946/gbd7jnxltDrWAPvo3eP0OcXP33VOwW7B67H2B+7J5cb7k8kmvan1VehsT92jwAPsT9k9yxtw/1J9x+JpuJnD32ye9L0Quh2z2FeCN3uKcWG0Fc17n3ek5OIsEM73yHo8lfvkFgrwssRADbzPJuJw4ETbSZOEl6+mVIdGi9TxGaeZjOj4TMK8vfNjI3NvJwrTC9qvfzf881s9BqiaPiMYjvopY4rDHUJuuEzitdBN3xG8TroBOj60A2fJLwOumHF/zrohpX566AbVtCvg25Y6b4MeoIivUFv1XS7gaYOoMNjx5OlOUdXx6qG6B3NoUORvgA6FOkLoEORvgA6Abo8dD+18ok+pTl0KNIXQIcifQF0KNIXQIci3QB6yuMKY3YNJZVTGGedU1lQUpCvO9+hDK279x2CMN77DkFFb7BD9yabsTzMum+HILn3vkOEHdoggZ5+9B5DyHPo0OcvD4s61mnl7Nx8hyDm975DUP5736EzHRO0+v/lMynu1mLLmcRrc7HQgVuUAtD0ErMS5xlSgbR7AXSotRdApzNBHyoH/W2xpxI+rcUeSEOk0FjsxfY4aeceAmTxNZIf4uN+bVm69oSvfCu7lyZlSnmGh8R9eeeHEGi6+vGzy7LcyHS/PJcPl7/R2b0seCmd3euIV9KpuxceG9JxaXqHt3OZhjmd3SuVl9LZvaTYkk5O6U6nNC43/vyuu9dBap5S0zyOCHSe0Nm9wtmSTonTO5dcHRae37uXRC+ls3fdcFllfXiKPMdj/s3fde9CB9u5ajv3rsywnSu2Mw57l5LYzlXb+QLt68P04qbw8D388nZ6N522elcevi0Py1ff3wDrffmwQ2/r1VezwU0+FnzwjfUmimNylOih7qAsoyx1chxfHxb8nhvFIRhbL+1+vWX8XivFh4ks574Ux4tdfLiJuMtd8G25ce/LjSlOyy2N5aZy94Xy4Av5fbHJ0mKzpcUWS4uthhbrhlMttk4vx74cm+fZYp2lxe4+k5Jc7O7TKMnFkqXFniuDaiz2XBlUY7HnyqAaiz1XBtVY7LkyqOeL9ZYyKG8pg/KWMihvKYPyZGmxljIobymD8ifLoKYqyVTjfLEny6CeL/ZkGdTTxYaTZVDPF3uyDOr5Yk+WQT1f7MkyqOeLJUuLPVkG9XyxJ8ugni/WUgYVLGVQwVIGRZYyKLKUQZGlDIosZVAvaKX9wsVayqDIUgZFljIospRBkaUMKlrKoKKlDCpayqCipQzqBV1BX7hYSxlUtJRBRUsZVLSUQUVLGVSylEElSxlUspRBJUsZ1Au62L1wsZYyqGQpg0qWMqhkKYNKljKobCmDypYyqGwpg8qWMqgX9Bl64WItZVDZUgaVLWVQ2VIGlS1lUMVSBlUsZVDFUgZVLGVQL2gU8sLFWsqgiqUMqljKoIqlDKpYyqCqpQyqWsqgqqUMqlrKoF7QueCFi7WUQVVLGVS1lEFVSxlUNZRBpcFQBpUGQxlU2v+7ySUXayiDSgNZWqyhDCqd7J3kjcUayqDSyd5J3lispQzqbO8kf75YSxnU2d5J/nyxljKos72T/PliLWVQZ3sn+fPFWsqgzvZO8ueLZTKoMLhpscHlx8XexnGv9w556pHqKdJzSKVOTbzr4O7Lzkur9pXGZq1h8A8d1a505zNJFEZIl7/p3q9tueudd1OPPO/oztSXsvTpIU0NrsgNH65+w+ME8NTB3/E8ONwinpDG7nTk7p/raNwvLzKhyfGqG8rzCbka7x0Na4zpuZ82e6Ql7lXcR1oCHX8JUXsJfnBlis0h1A/N9n64/ONvf/zy66+//OOvv/7+9x///OX33/51HTxc/9/yj2+jG4M3Rv9tqCz/hPX5EL9+SFg/hFYOufzLXa9cfuVfmtyiDPdbiwv1amv5xXnPh7j1Q/z6IWH9EFo/ZNHHi5+GUJkNSeuH5PVDyvohdfWQ5Zf+PB/i1g/x64eE9UNo/ZDl3S/j/e1yh/wwZOlZPN7dwkO73RBuOdfySzzkPj5v+/Fl24+vm3788vNA7uPdth/vt/34IPjxJcw+nrb9+Ljtxy9GbZ1EQw352/vI8s+vnw8p64fU1UOWf1D7fIhbP8SvHxJWD1kuk38+JK4fsrj7lzx3TEtT/tZhlgufnw8p64fU1UOWS1mfD3Hrh/j1QxZ33+ep63qdReVyid/zIXH9kLR+SF4/pKwfUlcOufzL3yTB4vSSHw9YUkrfyo/lt6Q/H1JXD2GEx9Mhbv0Qv3LI5V/hxm05dupQJuLxm3bnl3/R9Vq3fGBcEo1nPCWVx0fU0imVc4ObZPbl7/jh+svK3PJJrbiVomKlalhZPslcbWU67r3+7eZWnIoVr2IlqFghFStRxUpSsZJVrBQVK1XDSlCJ/aAS+0El9oNK7AeZ2K8PVuqClahiJalYySpWioqVqmGFBhUrTsWKV7ESVKyoxD6pxD6pxD6pxD6JxP7lkTtZuV3zrZWqYSUOKlacihWvYiWoWCEVK1HFSlKxklWsqMR+VIn9pBL7SSX2k0zsp3S3kvLcSlCxQipWooqVpGIlq1gpKlaqhpU8qFhxKlZUYj+rxH5Wif2sEvtZJPb9kCcrfihzK1nFSlGxUjWslEHFilOx4lWsBBUrpGIlqlhRif2iEvtFJfaLSuxXmbUEd7dC9K0VP4jEfqG7lUJ+bsWrWAkqVkjFSlSxklSsZBUrRcVK1bDiBhUrKrHvVGLfqcS+U4l9JxP7ud6tlGFuJalYySpWioqVqmFFpranacWpWPEqVoKKFVKxohL7XiX2vUrse5XYl6ntqe6e81c3y/m9TG1P04pTseJVrAQVK6RiJapYSSpWsoqVomJFJfZJJfZJJfZJJfZlanvqQ11fndf1eZnanqaVqGIlqVjJKlaKipWqYUWmtqdpxalY8SpWVGI/qsR+VIn9qBL7MvUwNYe7lTI/tRapIblk2+NPoC5/+/laRGpI2lZIxUpUsZJUrGQVK0XFStWwIlJD0rbiVKysjv3bqNA1irpGxa5RqWtU7hpVukbVnlHraxhuo1zXqC7fKF2+Ubp8o3T5RunyjdLlG6XLN0qXb9Qu36hdvlG7fKN2+Ubt8o3a5Ru1yzdql2/ULt+oPb4RhqFrlOsa5btGha5R1DUqdo1KXaNy16jSNarLN1yXb7gu33BdvuG6fMN1+Ybr8g3X5Ruuyzdcl2+4Lt/wXb7hu3zDd/mG7/IN3+Ubvss3mO8Hs5/eTJVDmY/KXaNK16jaM4r5fq01ynWN8l2jQtco6hoVu0Z1+Ubo8o3Q5Ruhyzeoyzeoyzeoyzeoyzeoyzeoyzeoyzeoyzeoyzeoyzdil2/ELt+IXb4Ru3wjdvlG7PIN7h2iw/Ra0+KG+ajcNap0jao9o7j3czZGua5RvmtU6BpFXaNi16gu30hdvpG6fCN1+QZz7np/91oN+WP95/xElMr0AkIqDy/5nGw4BRtewUZQsEEKNqKCjfR1G5H8WF4RH19+f30D4MK5/ODqVLU8ePfNGwOvc8oSc5q++Ivlof/F8pxSGkVMSg/Pm5Lf5lN2Np+6r/mUQXs+5O79Ph67OoweVNzuZuR3N6OwuxnR7mYUdzejtLsZ5d3NqOxuRnVvM6q7u2fX3d2z6+7u2XV39+y6u3t23d09u+7unl03vmffbBQFG3VzGzRI3ClLdpONMsxtOAUbXsFGkLaR5zZIwUZUsCFxV6jTD4Dj7N37VxtZwUbZ3oaT8N2a6mSjprkNgT2/qOPRRsouzG2s3vPbqNw1qvSM8gJ3uzS4sbQ7DX5OwQvcJZKfXtiaPtR2jjZIwUZUsJEUbGQFG0XBRt3eRhgUbDgJG1MGuGzDK9gICjZIwYZEnIepf3MKaZ4NhKRgIyvYKAo26vY2aFCw4RRsSMT5Jf8abZBfsBEUbJCCjahgQyLOL/rkbqPMbWQFG0XBRt3eRhwUbDgFG17BRhC2EeLcBinYiAo2ROK8TveSOMzvJTEr2CgKNur2NpJInKdyt/ExPhbOG+696f3DqeLbd+aU3M7m43c2n7Cz+dAL50PDfD5xZ/NJO5tP3tl8ivZ80nT8nEqaz6fuaz552Nl83M7m43c2n7Cz+dDO5hP15zMlpCXO55N2Np+8s/mUnc1nZ/fnsrP7c9nZ/bns7P5cdnZ/Lju7P5e4s/ns7P5cdnZ/Lju7P5e6r/nUnd2f687uz3Vn9+e6s/tz3dn9ue7s/lzTzuYjcX+OZWzmltIw/95booKzVRElUcHZsBElKjibNpyCDa9gIyjYIAUbUcFGUrCRFWwUBRsKce4U4twpxLlTiHOnEOdOIc4VqnajU4hzpxDnTiHOnUKce4U49wpx7hXi3CvEuVeIc68Q514hzr1CnHuFOPcKcR4U4jwoxHlQiPOgEOdBIc6DQpwHhTgPCnEeFOI8KMQ5KcQ5KcQ5KcQ5KcQ5KcQ5KcQ5KcQ5KcQ5KcQ5KcR5VIjzqBDnUSHOo0KcR4U4jwpxHhXiPCrEeVSI86gQ50khzpNCnCeFOE8KcZ4U4jwpxHlSiPOkEOdJIc6TQpxnhTjPCnGeFeI8K8R5VojzrBDnWSHOs0KcZ4U4zwpxXhTivCjEeVGI86IQ50UhzotCnBeFOC8KcV4U4rwoxHlViPOqEOdVIc6rQpxXhTivCjG4vmvb3IbzwzAWq13+drFxffB1XEEI7v5O8lv1XFrfEW7zGbkXzChMb0QL4eENdXnhWnLT7Mm7/O3s/aFnHw49ezr07OOhZ58OPft86NmXQ8++Hnn2bjj07A/9rHWHfta6Qz9r13dV3dXsD/2sdYd+1rpDP2vdoZ+17tDPWn/oZ60/9LPWH/pZ6w/9rF3fpXpXsz/0s9Yf+lnrD/2s9Yd+1vpDP2vDoZ+14dDP2nDoZ2049LM2HPpZGw79rA2HftaGQz9rw6GfteHQz1o69LOWZO73wd1nT+HD9TcrMvflNNyt5DK3ElWsJBUrWcVKUbFSNazEQcWKU7HiVawEFSsqsR9VYj+qxH4UiX03XX75Ow1zK0XFStWwkgYVK07FilexElSskIqVqGIlqVhRif2kEvtJJfazSOx7HycrfiGDzU7FilexElSskIqVqGIlqVjJKlaKipWqYaWoxH5Rif2iEvtFJPbDVFZ/+fux0+hohVSsRBUrScVKVrFSVKxUDSt1ULHiVKx4FSsqsV9VYr+qRKXIL36cn16Xffk7t65/+vuaLPKLH9kZuRfMSOr8O4v84ud1sw+Hnj0devbx0LNPh559PvTsy6FnX488ezccevaHfta6Qz9r3aGftSK/+Hnd7A/9rHWHfta6Qz9r3aGfte7Qz1p/6GetP/Sz1h/6WesP/awV+cXP62Z/6GetP/Sz1h/6WesP/az1h37WhkM/a8Ohn7Xh0M/acOhnrcgvfl43+0M/a8Ohn7Xh0M/acOhnbTj0s5YO/aylQz9r6dDPWjr0s1bkV1yvm/2hn7V06GctHfpZS4d+1kaZ+32d6kpdGD5ef7PiVayI3D9DrHcrxc+tiNzngk93KzHNrUQVK0nFSlaxUlSsVA0rIr9Ya1txKla8ipWgYkUl9pNK7CeV2Bf5xZojP/3Ky1Gc35NFfrHWtlI1rIj8Yq1txalY8SpWgooVUrESVawkFSsqsZ9VYj+rxL7IL9ZcdPcMNtI8Txb5xVrbilexElSskIqVqGIlqVjJKlaKipWqYaWqxH5Vif2qEvsiv1hzyd0z2MvQuRVSsRJVrCQVK1nFSlGxUhWsFJnf7TWtOBUrXsVKULFCKlaiihWZ2K/T26lcnv8mtsj89qpppahYqRpWZH5z1LTiVKx4FStBxQqpWIkqVlRi36nEvsxvNi7HOXcrdZhbqRpWZH4D0bTiVKx4FSu0uZXLv+L1arecldFFi7wPJpcf/LPEBVs+D+PMfPb3p/Lt21e3nJGJWvCbWwibW6DNLcTNLaTNLeTNLZTNLdStLbjNY9ptHtNu85h2m8e02zym3eYx7TaPabd5TLvNY9ptHtN+85j2m8e03zym/eYx7TePab95TPvNY9pvHtN+85j2q2P6OioMXaNc1yjfNSp0jaKuUbFrVOoalbtGLfuRp1Ggk4/5S360/EsPSQvLv8YQteA2t+A3txA2t0CbW4ibW0ibW8ibW9g8pmnzmI6bx3TcPKbj6pi+jQpdo6hrVOwalbpG5a5RpWtU7RmVhp5RmRmV0zQqL4xa3uVQxjZaRK7MR1HXqNg1KnWNYvarTqN8rfNRtWdUGbpGua5RvmtU6BpFXaNi16jUNSp3jeryjdLlG7XLN2qXb9Qu36hdvlG7fKN2+Ubt8o3a5Ru1yzdqj2/4Yega5bpG+a5RoWsUdY2KXaNS16jcNap0jeryDdflG67LN1yXb7gu33BdvuG6fMN1+Ybr8g3X5Ruuyzd8l2/4Lt/wXb7hu3zDd/mG7/IN3+Ubvss3fJdv+C7fCF2+Ebp8I3T5RujyjdDlG6HLN0KXb4Qu3whdvhG6fIO6fIO6fIM5gwt+OgUO4aNqm59qpErj1anGb94m4JkzOEkLScBCmc69U3k49363kDe3UDa3UCX2YYjTPvhv94E5g5O04Da34De3EDa3QJtbiJtbSJtbyJtbKJtb2Dym0+YxnTaP6bR5TKfNYzptHtNp85hOm8d02jym0+YxnTaP6bx5TOfNYzpvHtN585jOm8d03jym8+YxnTeP6bx5TOfNY7psHtNl85gum8d02Tymy+YxXTaP6bJ5TJfNY7psHtNl85ium8d03Tym6+YxXTeP6bp5TNfNY7puHtN185ium8d03TqmwzBsbsFtbsFvbiFsboE2txA3t5A2t5A3t1A2t7B5TLvNY9ptHtNu85h2m8e02zym3eYx7TaPabd5TLvNY9ptHtN+85j2m8e03zym/eYx7TePab95TPvNY9pvHtN+85j2m8d02Dymw+YxHTaP6SAS00/qNUKgzS3EzS2kzS3kzS2UzS0wMc3/JuT7VVdfbTDVUrI23NdtPK3OCczvOSUthM0tkICFp/cmiptbSJtbyJtbKJtbqFtbiMPmFtzmFvzmFsLmFjaP6SgS08+eQjFtbiFvbqFsbqFubSENm1tYHXHXN/ul67XLibVzQ743GBvqw+B6G5ufjB3caNYNIT6YXVhXHsZlZecfL72lUdt+PH3940MYP/7xnexvHx8FPn781XxO4duPT1//+DK+Uz7X/O3H520/vnz548vUbanQbGurwMeP/l8eWzndPn459V738Xl6SecMznLW3fnx9Ru/v/yjPI37e1eWoXzOpR3dbxUpPZ9Y88ZSrxdzOfsk0MrD+i+Rd4VG64fE9UPS+iF5/ZCyfsiix8c4xkhMsyHLqebzIW79EL9+yOLuxzy+XiI+9gR9H0Lrh8T1Q9L6IYu7H+v0MB/CbEhZP6SuHrKclDwf4hpDnJsN8euHhPVDFnc/ZTdp9mE2JK4fktYPWdz9y2nClMrRbEhZP6SuHrJcCp2H6Yn9mC6+D3Hrh/j1Q8L6IdQY4tNsSFw/JK0fsrj7eercW4b5vpT1Q+rqIctFs8+HLL83fVp+me8L0/Ts6ZCwfgitH7LcZ2DK5T/kk+9D0vohef2Qsn5IbQyJs5sS01zr6RC3fsji7leXx7x0Hi/LFY3Ph9D6IXH9kMXdr2G881eaPZKWqwKfDynrh9TVQ5g3+dcpIaspzce4jjG+Y0zoGEONMZnmY2LHmNQxhlHRcWrrMaRhPqp0jao9o9ywetR/r8ZuEnI5h6ojkRwfU8glNUhpzOqiHz5c+wN3wiH38Xnbjy/bfnzd9OOXTzjkPt599eOjvwvI3Lj2csu7e/Nwl2iebqeny19BvmoyYU+ToT1NJupOxtE0GR9mk0l7mkze02TKniZTdScTyjQZyt9OJg57mozb02T8niYTXjaZGGeToT1NJu5pMsp34Dz1Xx5KmU0m72kyZTeTuUoFd5MKi0HlYx1Vt0+P37JdZngb668XMyfVbjx8iPHxVMQ/Oal+OsSvHxLWD6GVQ64Uwo0g863A9A1xfPzuYbiMvPzz//34xy8//u3Xn/91GXL9X//929///OX3397/+ef//+f4v/ztj19+/fWXf/z1n3/8/veff/r3Hz//9dff/3793757U3oX25dDBXI/vGm/v6T0fXa3yV3/59t/yvn74n942/C/XCL2+4tnXK/w4wdcviWMcfyAi2xOtw8I0wdcvuwOtxH0bvcv5TKkpPTD7aq/lPx9zeP44i/mwmTvehRVQpz6Fd4+7zKjUMv76MsxfZmmH1K82BrG0SHT5Z9pqol4uyZ+T8NU6nD7T9cVDNM3qG//KXxPZfre8vaf3OWbYxeGu05+Ixa/z8M9ID6acL5B+U6JLhdcZvrfywb/Hw==",
      "brillig_names": [
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "notify_created_nullifier_oracle_wrapper",
        "get_notes_internal",
        "get_collapse_hints",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_public_keys_and_partial_address",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "public_get_name",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18105278452957613314": {
            "error_kind": "string",
            "string": "Function public_get_name can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "compressed_string::field_compressed_string::FieldCompressedString"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JgACBAEnAAABBIBFJgAABAMmAgEEACYCAgQAHxgAAgABgEQkAAAARSQAAABGLQQAAYBEJwIAAgSARCYCAwQBOg0AAgADJSQAAACbHgIAAQAeAgACADI4AAEAAgADJgIBAQEjAgADAAAAbyQAAADEHgIAAQkmAgIAAQo4AQIDIwIAAwAAAIskAAAA1iYCAQACLgwAAQACLAwCASUnAIAEBHgADQAAAIAEgAMjAIADAAAAwykBAAEF96Hzr6Wt1Mo7AQECJSkBAAEFvh4//z6k9vo7AQECJSkBAAEF+0Le07wSjQI7AQECJS0AGMoYyg==",
      "debug_symbols": "5ZXBbsIwDIbfJece4thxEl5lmlCBgCpVLSpl0oR49yWohNJVoHVll12iOPoc/7GT+CQ2fnXcLYtqWx/E4u0kynqdt0VdBet0zsSqKcqy2C37y0LGwegLf9jnVTQPbd60YgHMKhO+2sSpUWGHbVF6seAw/Q5Lqa+wVDrBAGaEJiLT0USaE231CGwxbW1RQR9+z4SVM2i3CQ7i/1D7HHknSHnnZ3kHzYnmSDzS7tBdYUdIA+0OZ9UO8l57jGBfHSFk7OUhAH4dgp283jh2Cp9UTaadnbR6UDWAn544OimY4jQlEtIUJzfmhGG9c0LovdPRFCuFsoOV0r0qMo/QBi12tCFJjwtiIP0uRt1/ASO3CSTi7ToxD+tH9E/Oeg7WR94U+ar0XQPbHqt1r5+1n3s/aG37pl77zbHxscnd+hvEHqFchnR5AsFAnaEJMUKcLw==",
      "brillig_names": [
        "public_get_name"
      ]
    },
    {
      "name": "public_get_symbol",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "15009911310769716579": {
            "error_kind": "string",
            "string": "Function public_get_symbol can only be called statically"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "compressed_string::field_compressed_string::FieldCompressedString"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JgACBAEnAAABBIBFJgAABAMmAgEEACYCAgQAHxgAAgABgEQkAAAARSQAAABGLQQAAYBEJwIAAgSARCYCAwQBOg0AAgADJSQAAACSHgIAAQAeAgACADI4AAEAAgADJgIBAQEjAgADAAAAbyQAAAC7HgIAAQkmAgIAAQo4AQIDIwIAAwAAAIskAAAAzS4MAAIAASUnAIAEBHgADQAAAIAEgAMjAIADAAAAuikBAAEF96Hzr6Wt1Mo7AQECJSkBAAEFvh4//z6k9vo7AQECJSkBAAEF0E3qz6yL/WM7AQECJS0AGMoYyg==",
      "debug_symbols": "vZRhi8IwDIb/Sz/vQ5O0aetfOUSmVhmMTeY8OMT/fq1sdXpDud28L6MZT/qmSXjPYuvXp/2qqHb1USw+zqKsN3lb1FWIzpdMrJuiLIv9avhbyPgx+sofD3kVw2ObN61YADNmwlfbeDQYbtgVpRcLDsefsJS6hyXqBAOYEVopZTpaKc2JtnoEtpSutoQwhJeZsHKG2m2CQ/H/WPscfVeQ+s6v+g6aE82ReFa7I9fDTpF6qN3RrLWDvK89Kth3K4SOvV0C4M8S7GS/ceyQXkxNppudtPphagC/fXFMQpiSNEWJ1JQkN5ZEZPquETl+3mJEkh2MqAdTZB6hDVnqaKOkej4QA8ldDN5bwMg2gSS6rRPf2cvyEqLPvCnydek7U9+dqs3A49uvg3+w+0NTb/z21Pho/DfPh+ibaDLC61qEIAiTDhpB5xs=",
      "brillig_names": [
        "public_get_symbol"
      ]
    },
    {
      "name": "transfer_in_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "10846690067871036662": {
            "error_kind": "string",
            "string": "invalid owner"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          }
        },
        "parameters": [
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JgACBAEnAAABBIBLJgAABAMmAgUEBCYCBgQAHxgABgAFgEctCIBHAAEtCIBIAAItCIBJAAMtCIBKAAQkAAAAVyQAAACUJwIAAQSASyYCAgQAOg0AAQACJwCAQwAAASgAgEQAR9rNcysAgEUAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAnAIBGBAADJSQAAAgaHgIABQAeAgAGADI4AAUABgAHJgIFAQEjAgAHAAAAvSQAAAhDHgIABQEKOAEFBiYCBQQAJgIHBAImAggEASYCCQAAIwIABgAABlYiAAAA6B4CAAYBLAgBCiYCCwQCABABCwEmAwoEAQAoCgILHzwABQAIAAsAKAoCDAA4DAUNLA0NCxwMCwwEHAwMCgAmAgsEBCwIAQwmAg0EBQAQAQ0BJgMMBAEAKAwCDR88AAgACwANLA0MDQAoDQINLA4NDAAoDAIOADgOBQ8sDQ8NACgMAg8AOA8IECwNEA4AKAwCEAA4EAcRLA0RDwAoDAIRASgAEYBGABIsDRIQJgIMACwsCAERJgISBAYAEAESASYDEQQBACgRAhIsDBITLA4MEwAoEwITLA4NEwAoEwITLA4OEwAoEwITLA4PEwAoEwITLA4QEyoCAAwAAAAAAAAAAAUAAAAAAAAAACYCEgQTLAgAEywMDBQAEAASACQAAAhVLAQAACwMFA0sDBUOLAwWDywMFxAsDQ0MACgMAgwsDgwNLAgBDAAAAQIBLA4NDCwNDg0AKA0CDSwODQ4sCAENAAABAgEsDg4NLAgBDgAAAQIBLA4PDiwIAQ8AAAECASwOEA8mAhAEBSwMBQQiAAACdww4BBASIwIAEgAABeYiAAACiSYCEQQSLAgAEiwMDBMsDA0ULAwOFSwMDxYAEAARACQAAAj8LAQAACwMExAmAgwALSwIAQ0mAg4EBQAQAQ4BJgMNBAEAKA0CDiwMDg8sDgwPACgPAg8sDgYPACgPAg8sDgoPACgPAg8sDhAPLA0NBgAoBgIGLA4GDSoCAAYAAAAAAAAAAAQAAAAAAAAAACYCEAQRLAgAESwMBhIAEAAQACQAAAhVLAQAACwMEgosDBMMLAwUDiwMFQ8sDQoGACgGAgYsDgYKLAgBBgAAAQIBLA4KBiwNDAoAKAoCCiwOCgwsCAEKAAABAgEsDgwKLAgBDAAAAQIBLA4ODCwIAQ4AAAECASwODw4sDAUEIgAAA5gMOAQLDyMCAA8AAAV2IgAAA6omAgsEDywIAA8sDAYQLAwKESwMDBIsDA4TABAACwAkAAAI/CwEAAAsDBAEKAIABgAnFrFmJgILBAMmAg0EAwA4Cw0MLAgBCgAQAQwBJgMKBAEAKAoCDCwOCwwAKAwCDCwOCwwmAgwEAwA4CgwLLAwLDCwOBgwAKAwCDCwOAQwAKAwCDCwOBAwsDQoEACgEAgQsDgQKLAgBBCYCBgQDABABBgEmAwQEAQAoBAIGLAwGCy0KgEUACwAoCwILLQqARQALACgEAgYAKAoCDSwNDQwmAg4EAgA4DQ4LOAOlAAaAQwALAAwADSACAAQsCAEKACgKAg4sDQ4MJgIPBAIAOA4PCyE8AAUABAALLAwEDCYCDwQDADgMDw4AEAEOASYDCgQBACgKAg8sDgwPACgPAg8sDgwPLAwMBgYoBgIGLA0KBAAoBAIELA4ECiMCAA0AAAUcIgAABQAAKAoCDCwNDAsmAg0EAgA4DA0EOw0ECyIAAAUcCjgGCAQjAgAEAAAFLiQAAAmAACgKAgYsDQYGDDgFBgsjAgALAAAFSSQAAAmSJgILBAMAOAoLBgA4BgULLA0LBAsoAASARAAGIwIABgAABXEkAAAJpCIAAAZtIwIADwAABYMiAAAF2CYCEAQEDDgEEBEjAgARAAAFmiQAAAmSACgNAhAAOBAEESwNEQ8mAhAEESwIABEsDAYSLAwKEywMDBQsDA4VLAwPFgAQABAAJAAACbYsBAAAIgAABdgAOAQIDywMDwQiAAADmCMCABIAAAXzIgAABkgmAhMEBQw4BBMUIwIAFAAABgokAAAJkgAoEQITADgTBBQsDRQSJgITBBQsCAAULAwMFSwMDRYsDA4XLAwPGCwMEhkAEAATACQAAAm2LAQAACIAAAZIADgECBIsDBIEIgAAAncKOAQJBiMCAAYAAAZoJAAACuUiAAAGbSYCBgAGLAgBCiYCCwQDABABCwEmAwoEAQAoCgILLAwLDCwOBgwAKAwCDCwOAwwqAgADAAAAAAAAAAACAAAAAAAAAAAmAg4EDywIAA8sDAMQABAADgAkAAAIVSwEAAAsDBAGLAwRCywMEgwsDBMNLA0GAwAoAwIDLA4DBiwIAQMAAAECASwOBgMsDQsGACgGAgYsDgYLLAgBBgAAAQIBLA4LBiwIAQsAAAECASwODAssCAEMAAABAgEsDg0MLAwFBCIAAAcyDDgEBwUjAgAFAAAHqiIAAAdEJgIFBA0sCAANLAwDDiwMBg8sDAsQLAwMEQAQAAUAJAAACPwsBAAALAwOBAo4BAkDJgIFAQAKOAMFBiMCAAYAAAeLJAAACvcuDAAEAAMKOAMBBSMCAAUAAAejJAAACwkvDAACAAQlIwIABQAAB7ciAAAIDCYCDQQCDDgEDQ4jAgAOAAAHziQAAAmSACgKAg0AOA0EDiwNDgUmAg0EDiwIAA4sDAMPLAwGECwMCxEsDAwSLAwFEwAQAA0AJAAACbYsBAAAIgAACAwAOAQIBSwMBQQiAAAHMicAgAQEeAANAAAAgASAAyMAgAMAAAhCKQEAAQX3ofOvpa3UyjsBAQIlKQEAAQW+Hj//PqT2+jsBAQIlJAAACBomAgIAACwIAQMmAgQEBAAQAQQBJgMDBAEAKAMCBCwMBAUsDgIFACgFAgUsDgIFACgFAgUsDgIFLA0DBAAoBAIELA4EAywIAQQmAgUEBQAQAQUBJgMEBAEAKAQCBSwMBQYsDgIGACgGAgYsDgIGACgGAgYsDgIGACgGAgYsDgEGJgIBBAAmAgIBACwMAgUsDAEGLAwEAiwMBQQsDAMBLAwGAyUkAAAIGiwNBAUmAgYBAAo4BQYHIwIABwAACSAmAggEADsJAQgmAgUEBiwIAAYsDAEHLAwCCCwMAwksDAQKABAABQAkAAALGywEAAAsDQEFLA0CBiwNAwcsDgUBLA4GAiwOBwMmAgEBASwOAQQmAgEEAAAoBgIDADgDAQQsDQQCLAwCASUpAQABBQ0KLvL2wvvvOwEBAiUpAQABBeidCf6hES0OOwEBAiUpAQABBUSNqimioUC3OwEBAiUkAAAIGiwNAwYsDQQHJgIIAQAKOAcICSMCAAkAAAneJgIKBAA7CQEKCygABoBGAAcmAgYEASMCAAcAAApxIgAACfgsDQEHLA0CCCwNAwksDQQKJgIMBAMMOAkMDSMCAA0AAAofJAAACZItBAAHgAMnAIAEBAAEJAAADHgtCIAFAAsAKAsCDAA4DAkNLA4FDQA4CQYFDjgJBQcjAgAHAAAKXCQAAA0GLA4LASwOCAIsDgUDLA4KBCIAAArkJgIHBAgsCAAILAwBCSwMAgosDAMLLAwEDAAQAAcAJAAACxssBAAALA0BBywNAggsDQQJJgIKBAAtBAAHgAMnAIAEBAAEJAAADHgtCIAFAAsAKAsCDAA4DAoNLA4FDSwOCwEsDggCLA4GAywOCQQiAAAK5CUpAQABBYydEbQ59GaQOwEBAiUpAQABBQLcbieAdhKdOwEBAiUpAQABBZaHLyYENfT2OwEBAiUkAAAIGiYCBgQBJgIHBAAsDAcFIgAACzMNKAAFgEYAByMCAAcAAAujIgAAC0gsDQEFLA0CBiwNAwcsDQQIJgIJBAQsCAEKJgILBAUAEAELASYDCgQBACgGAgsmAgwEBAAoCgINPg8ACwANLA0KBgAoBgIGLA4GCiwOBQEsDgoCLA4HAywOCAQlLA0DBww4BQcIADgFBgcjAgAIAAALviIAAAxvLA0BCCwNAgksDQMKLA0ECyYCDQQEDDgFDQ4jAgAOAAAL5SQAAAmSACgJAg0AOA0FDiwNDgwmAg4EAww4BQ4PIwIADwAADAokAAAJkgAoCAIOADgOBQ8sDQ8NADgMDQ4mAg0EBAw4BQ0PIwIADwAADDQkAAAJki0EAAmAAycAgAQEAAUkAAAMeC0IgAUADAAoDAINADgNBQ8sDg4PLA4IASwODAIsDgoDLA4LBCIAAAxvLAwHBSIAAAszLQGAA4AGCwCABgACgAcjAIAHAAAMkyIAAAyeLQCAA4AFIgAADQUtAAABgAUBAAABgAQAAQEAgAOABIAJLQCAA4AKLQCABYALCwCACoAJgAwjAIAMAAAM8S0BgAqACC0CgAiACwEAgAoAAoAKAQCACwACgAsiAAAMwCcBgAUEAAEDAIAGAAKABiIAAA0FJSkBAAEFRafKcRlB5BU7AQECJS0AGMoYyg==",
      "debug_symbols": "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",
      "brillig_names": [
        "transfer_in_public"
      ]
    },
    {
      "name": "_store_payload_in_transient_storage_unsafe",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16958085610837407363": {
            "error_kind": "string",
            "string": "Function _store_payload_in_transient_storage_unsafe can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [
          {
            "name": "slot",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "point",
            "type": {
              "fields": [
                {
                  "name": "x",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "y",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "is_infinite",
                  "type": {
                    "kind": "boolean"
                  }
                }
              ],
              "kind": "struct",
              "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
            },
            "visibility": "private"
          },
          {
            "name": "setup_log",
            "type": {
              "kind": "array",
              "length": 9,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JgACBAEnAAABBIBRJgAABAMmAgYEDSYCBwQAHxgABwAGgEQdAIBHgEcBLQiARAABLQiARQACLQiARgADLQiARwAEJwIABQSASCYCBwQJLAgBBiYCCAQKABABCAEmAwYEAQAoBgIILQQABYADLQQACIAELQQAB4AFJAAAAJ0sDAYFJAAAAOMkAAAA6ycCAAEEgFEmAgIEADoNAAEAAgEAgAOABYAHLQCAA4AILQCABIAJCwCACIAHgAojAIAKAAAA4i0BgAiABi0CgAaACQEAgAgAAoAIAQCACQACgAkiAAAAsSUnAIBDBAADJSQAAAOCLAgBBwAAAQIBJgIIAQAsDggHLAgBBwAAAQIBJgIIAAAsDggHLAgBBwAAAQIBJgIJAAIsDgkHHgIABwAeAgAJADI4AAcACQAKJgIHAQEjAgAKAAABSiQAAAOrHgIABwEeAgAJAAo4BwkKIwIACgAAAWYkAAADvRwMBAcALAgBBCYCCQQEABABCQEmAwQEAQAoBAIJLAwJCiwOAgoAKAoCCiwOAwoAKAoCCiwOBwomAgIEASYCAwQALAwDBiIAAAGwDSgABoBDAAcjAgAHAAADPyIAAAHFJgIGAAMAOAEGBywIAQEmAgYECgAQAQYBJgMBBAEAKAECBiwMBgksDggJACgJAgksDggJACgJAgksDggJACgJAgksDggJACgJAgksDggJACgJAgksDggJACgJAgksDggJACgJAgksDggJACgJAgksDggJLAgBBgAAAQIBLA4BBiYCAQQJLAwDBCIAAAJSDDgEAQgjAgAIAAACxyIAAAJkLA0GBSwMAwQiAAACcQw4BAEDIwIAAwAAAoQiAAACgyUcDAQDAAA4BwMGJgIIBAkMOAQICSMCAAkAAAKlJAAAA88AKAUCCAA4CAQJLA0JAy8MAAMABgA4BAIDLAwDBCIAAAJxJgIJBAkMOAQJCiMCAAoAAALeJAAAA88AKAUCCQA4CQQKLA0KCCwNBgkmAgsECQw4BAsMIwIADAAAAwckAAADzy0EAAmAAycAgAQEAAokAAAD4S0IgAUACgAoCgILADgLBAwsDggMLA4KBgA4BAIILAwIBCIAAAJSHAwGBwAAOAEHCSYCCgQDDDgGCgsjAgALAAADYCQAAAPPACgEAgoAOAoGCywNCwcvDAAHAAkAOAYCBywMBwYiAAABsCcAgAQEeAANAAAAgASAAyMAgAMAAAOqKQEAAQX3ofOvpa3UyjsBAQIlKQEAAQW+Hj//PqT2+jsBAQIlKQEAAQXrVzkD6KB2gzsBAQIlKQEAAQXonQn+oREtDjsBAQIlLQGAA4AGCwCABgACgAcjAIAHAAAD/CIAAAQHLQCAA4AFIgAABG4tAAABgAUBAAABgAQAAQEAgAOABIAJLQCAA4AKLQCABYALCwCACoAJgAwjAIAMAAAEWi0BgAqACC0CgAiACwEAgAoAAoAKAQCACwACgAsiAAAEKScBgAUEAAEDAIAGAAKABiIAAARuJS0AGMoYyg==",
      "debug_symbols": "1ZvRbuowDIbfpde9SGI7tvcqR9PENjYhIZgYO9LRtHc/KaNlA9ppWVbcG5SCTb7+aWwnkNfqfn778nizWD2sn6urP6/Vcn032y7Wq3T1+lZXt5vFcrl4vPn4duWal4Bu5/D8NFs118/b2WZbXfkYQ13NV/dNk0P6iofFcl5dxfB2XScnzHHSDCfK6YkkwymGHCfOcOKcnjhmOEnO4AplOGlOT/rdwa1PjZ2j1tgF6oy95zPWiMh7a0SKnbXQGWOB7qsFgv9ovIPXAvDSGSf68eDBlVAefad8/Ep5T7Gzjo3FELyCtsaKgMfwPhSF9+4z/K4L/vUuAv16F+B+3AXG0HaRmvrVQ8ehe+iEj8cNfn7HJedATuYDzAiOQJDjdDaJiai096Reh9ViYdgbswgMq5WCkevmsx4mXZBz8znNkL0xYPhk27BHmDA7T5f9fGUxEfYJ6y4T1l0mrLv6CbPTZNnRuQmz44TZdbrsUCJGQuzYSYbZmRBbY0I6qv7wfE0mGlsndeG4JsOemmzYqacYUuxqZY1QcNCCxHYcgsjhxuF9VYA9Bc7FeHqKlsvxGNNHjOkjxvTpKQIux0OmeKgnWV+OB43xqC0ebytfkBdbPMFWPKRgKx4S2IqHBNEWDxqLh2gsX6CxeEjG8gUZi4fG1hdkbH1BbCwesrF4qGPPL43tkj819Zgn+pHze/qVqNu3cIwnPKFEfC62cRERR8aJ3XBxZDnB0bFxCAZwaHR1uh2y1NQTHDWFE22pU2TnpyAOm8IRW+qILXWK7Pp8Cwe0w1E3bOy9x8M/e/znDLSjZzP0CYf92CWS6iHlupOUyz7a4gnG9AlqiwfQGI8xfdCYPihjl9hw4AE54SFbJT8T2+KJxvRhZ4yHbPGIN8YjtngUjPGoKR5xaIzHmD7e1vMj3la+ECjxv7hie0TS8wvQL+IM7REJjq7O0EpWMJrCIVvqkJrC6dlBuxiOLXXYljosY+MU3CMSQTP012/p6u9ss5jdLuf7M6UPL6u7D0dMt/+e5kenTZ8267v5/ctm3pw7PRw5bdYOXrQO3qXbbDJ5kBoktf3uI8baszaXfmfpai8hESSK/w==",
      "brillig_names": [
        "_store_payload_in_transient_storage_unsafe"
      ]
    },
    {
      "name": "compute_note_hash_and_optionally_a_nullifier",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 20
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "contract_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "storage_slot",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "note_type_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "compute_nullifier",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "packed_note_content",
            "type": {
              "kind": "array",
              "length": 3,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 4,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3djtw4koXfxde+EMng37zKYNHov2kYMOyGu3uBRWPefbPSJWVWiZVsRUgsMnTmwhi3FVTwO1QyTihT+vvDL7/+9NdvP3z68p+vf3z417///vD5688//vnp65fL3/7+78cPP3379Pnzp99+uP/PH6anP3y8Hv/H7z9+efrrH3/++O3PD//y9PHDr19++fCvYC/R//n0+dfr//2fjx+C2Xi83Xi823g8bTzebzw+bDx+K8+08fi87fg4bTx+o75xo75xo75xo75xo75xo75xo75xo75xo75po75po75po75po75po75po75po75po75po75po755o755o755o755o755o755o755o755o755o755o75mmrYGmK0BdmuA2xpAWwP81oCwNSBuDUhbA7YqbbYqbbYqbbYqbbYqbbYqbbYqbbYqbbYqbbYo/XF1YLTPB8a4HOifR85HjWynw0Y2h41sDxvZHTYyHTayP2zkcNjI8bCRD7sG7WHXoDvsGnSHXYPusGvQHXYNusOuQXfYNegOuwbdYdegO+wadLJrMLvnAy/1yeuhaTpuaHPc0Pa4od1xQ9NxQ/vjhg7HDR2PGzodN/RxV6M/7mr0x12NXrauw0Tz4GFKt4MvH9Wlo6OZD07hdmyK31Px/aQS+kkl9pNK6ieV3E0qYeonFdNPKrafVFw/qfTzaRuEn7aX6nM+1ISXqVyHD8cOH48dPh07fD50+DgdO7w5dnh77PDu2OHp2OGPvWrjsVdtPPaqjdKrdimUg/Wp8ulqnQ/PR1sXbkfbaL4nkztKJk09JWN6Ssb2lIzrKRnqKRnfUzKhp2Ri02TMkgw5+yKZ9dEphPnzOoVYSD2Nm3oeNvU8jZu6GTd1O27qbtzUadzUfcepU1hSz9M69TBu6j3vppXUe95NK6n3vJs+TN1OPe+mldR73k0rqfe8m1ZS73k3raTe825aSX3Y3dROPe+meUk9Olc7muxyNEWqHH2zvWTvoIRS0pc6b07aGnt/8BVgz3v6EAB7riyGANhzfTMCQNNzlTUEwJ5rvSEA9lxxDgGw57p3CIAEgDKAPXuAIQDCiQgBwokIAcKJCAHCicgAWjgRIUA4ESFAOBEhQDgRIUACQBlAOBEhQDgRIUA4ESFAOBEhQDgRGUAHJyIECCciBAgnIgQIJyIESAAoA4g6sAbwssgWgORfAyTs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",
      "brillig_names": [
        "compute_note_hash_and_optionally_a_nullifier"
      ]
    },
    {
      "name": "private_mint",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "11873158822563704285": {
            "error_kind": "string",
            "string": "Mismatch return note field."
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 17
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "1705275289401561847": {
            "error_kind": "string",
            "string": "Mismatch note header storage slot."
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6515419266667913063": {
            "error_kind": "string",
            "string": "zero token ID not supported"
          },
          "6869395374906889440": {
            "error_kind": "string",
            "string": "Mismatch note header contract address."
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "9296579303138805202": {
            "error_kind": "string",
            "string": "token already exists"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_notes_internal",
        "get_collapse_hints",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_public_keys_and_partial_address",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "random",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "10055739771636044368": {
            "error_kind": "string",
            "string": "Function get_admin can only be called statically"
          },
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "10536464181608181124": {
            "error_kind": "string",
            "string": "transfer not prepared"
          },
          "10846690067871036662": {
            "error_kind": "string",
            "string": "invalid owner"
          },
          "11859452850824495745": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 60
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "15009911310769716579": {
            "error_kind": "string",
            "string": "Function public_get_symbol can only be called statically"
          },
          "16541607464495309456": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 16
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16958085610837407363": {
            "error_kind": "string",
            "string": "Function _store_payload_in_transient_storage_unsafe can only be called internally"
          },
          "17028138060491915576": {
            "error_kind": "string",
            "string": "Function _finalize_transfer_to_private_unsafe can only be called internally"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18105278452957613314": {
            "error_kind": "string",
            "string": "Function public_get_name can only be called statically"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "364657447181031001": {
            "error_kind": "string",
            "string": "invalid admin"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5527120278801020911": {
            "error_kind": "string",
            "string": "invalid NFT owner"
          },
          "6515419266667913063": {
            "error_kind": "string",
            "string": "zero token ID not supported"
          },
          "7176719043052132708": {
            "error_kind": "string",
            "string": "Function _finish_transfer_to_public can only be called internally"
          },
          "8778930052620580050": {
            "error_kind": "string",
            "string": "caller is not an admin"
          },
          "9296579303138805202": {
            "error_kind": "string",
            "string": "token already exists"
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "9443383425599897888": {
            "error_kind": "string",
            "string": "Function owner_of can only be called statically"
          },
          "9605075991997100073": {
            "error_kind": "string",
            "string": "token does not exist"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JgACBAEnAAABBIBMJgAABAMmAgIEASYCAwQAHxgAAwACgEstCIBLAAEkAAAARSQAAADMJwIAAQSATCYCAgQAOg0AAQACJwCAQwQAAygAgEQAO5rKACcAgEUEAA0nAIBGAAABKACARwBH2s1zKwCASAAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACsAgEkAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAqAIBKAAAAAAAAAAABAAAAAAAAAAAlJAAAIhwoAgACANx37RMKOAECAyYCBAQAJgIGBAMAOAQGBSwIAQIAEAEFASYDAgQBACgCAgUsDgQFACgFAgUsDgQFJgIFBAMAOAIFBCYCBAQAJgIFAAMmAgYEASYCBwEAJgIIAAYmAgkAAiYCCgEBJgILAAAjAgADAAABTSIAAAWDJgINBD8sCAEOJgIPBEAAEAEPASYDDgQBACgOAg8fPAAGAA0ADywNDg0AKA0CDSwODQ4sCAENAAABAgEsCAEPAAABAgEAKA4CEQA4EQQSLA0SECwODg0sDgYPJgIRBBIsCAASLAwNEywMDxQsDAgVABAAEQAkAAAiRSwEAAAsDBMOLA0OEQAoEQIRLA4RDiYCEgQTLAgAEywMDRQsDA8VLAwIFgAQABIAJAAAIkUsBAAALAwUESwNEQ0AKA0CDSwODREsCAENAAABAgEsDgcNLAgBDwAAAQIBLA4LDywIARIAAAECASYCEwDZLA4TEh4CABQANTgAFAAVABYAIwIAFgAAAmMiAAACViwMBwMsDAsMIgAAAnAsDAoDLAwVDCIAAAJwIwIAAwAAAoEmAhcEADsJARc1OAAUAAMAFwIjAgAXAAACpCIAAAKXLAwHFSwMCxYiAAACsSwMChUsDAMWIgAAArEjAgAVAAACwiYCFAQAOwkBFCwIARQmAhUEAgAQARUBJgMUBAEAKBQCFR88AAQABgAVLA0UFQAoFQIVLA4VFAAoFAIXADgXBBgsDRgVHAwVFwQcDBcUACYCFwQYLAgAGCwMBxksDAsaLAwTGwAQABcAJAAAJJgsBAAALAwZFSYCEwANLAgBFyYCGAQEABABGAEmAxcEAQAoFwIYLAwYGSwOExkAKBkCGSwOFBkAKBkCGSwOFRksDRcTACgTAhMsDhMXKgIAEwAAAAAAAAAAAwAAAAAAAAAAJgIaBBssCAAbLAwTHAAQABoAJAAAN/csBAAALAwcFCwMHRUsDB4YLAwfGSwNFBMAKBMCEywOExQsCAETAAABAgEsDhQTLA0VFAAoFAIULA4UFSwIARQAAAECASwOFRQsCAEVAAABAgEsDhgVLAgBGAAAAQIBLA4ZGCwMBAMiAAAECQ0oAAOAQwAZIwIAGQAAIawiAAAEHiYCFwQZLAgAGSwMExosDBQbLAwVHCwMGB0AEAAXACQAADieLAQAACwMGgMKOBYDEyMCABMAAARbJAAAOSIKOAwLAx4CABMBCjgMExQSOAMUDCMCAAwAAAR8JAAAOTQKOBALAwo4AwcMIwIADAAABJMkAAA5RiYCAwQTLAgAEywMDRQsDA8VLAwSFiwMBRcsDBAYABAAAwAkAAA5WCwEAAAmAgwEEywIABMsDA4ULAwKFQAQAAwAJAAAOWQsBAAALAwUAyYCDAQTLAgAEywMDRQsDA8VLAwSFiwMCRcsDAMYABAADAAkAAA6bCwEAAAmAgwEEywIABMsDBEULAwKFQAQAAwAJAAAOWQsBAAALAwUAyYCDAQTLAgAEywMDRQsDA8VLAwSFi0IgEYAFywMAxgAEAAMACQAADpsLAQAAB4CAAMAMwIAAwAoAgINLA0NDCYCDgQCADgNDgM6DQADAAwiAAAFgygCAAMAli3rAgo4AQMMLA0CAwAoAwIDLA4DAiwNAgMAKAMCAywOAwIsDQIDACgDAgMsDgMCLA0CAwAoAwIDLA4DAiwNAgMAKAMCAywOAwIsDQIDACgDAgMsDgMCIwIADAAABewiAAAHSywIAQMmAgwEAgAQAQwBJgMDBAEAKAMCDB88AAYABgAMLA0DDAAoDAIMLA4MAywIAQwAAAECASwOAwwsCAEDAAABAgEsDgQDJgIOBA8sCAAPLAwMECwMAxEAEAAOACQAADqqLAQAACwMEA0AKA0CDAA4DAQOLA0OAywIAQwAAAECASwOBwwsCAENAAABAgEsDgsNLAgBDgAAAQIBJgIPANgsDg8OJgIPBBAsCAAQLAwMESwMDRIsDA4TABAADwAkAAA7JSwEAAAmAhAEESwIABEsDAwSLAwNEywMDhQsDAUVABAAEAAkAAA7TywEAAAsDBIPHgIAEAEKOA8QESMCABEAAAb1JAAAO18mAg8EECwIABAsDAwRLAwNEiwMDhMsDAUULAwDFQAQAA8AJAAAOVgsBAAALA0CAwAoAwIDLA4DAgAoAgINLA0NDCYCDgQCADgNDgM6DQADAAwiAAAHSygCAAMA6v/ysQo4AQMMJgIDAAQmAg0ABSYCDgQCJgIPAE0mAhAAESYCEQBPIwIADAAAB4QiAAAJyCwIAQwmAhIEAwAQARIBJgMMBAEAKAwCEh88AAYADgASLA0MEgAoEgISLA4SDCwIARIAAAECASwODBIsCAEMAAABAgEsDgQMJgIUBBUsCAAVLAwSFiwMDBcsDAMYABAAFAAkAAA7cSwEAAAsDBYTJgIVBBYsCAAWLAwSFywMDBgsDBAZABAAFQAkAAA8FSwEAAAsDBcULAgBDAAAAQIBLA4HDCwIARIAAAECASwOCxIsCAEVAAABAgEmAhYA0ywOFhUmAhYEFywIABcsDAwYLAwSGSwMFRoAEAAWACQAADslLAQAAAo4FAsWCjgWBxcjAgAXAAAIfyQAADy5JgIaBBssCAAbLAwMHCwMEh0sDBUeLAwNHywMDyAsDBQhABAAGgAkAAA8yywEAAAsDBwWLAwdFywMHhgsDB8ZJgIbBBwsCAAcLAwWHSwMFx4sDBgfLAwZIAAQABsAJAAAPdEsBAAALAwdGgo4GgcWIwIAFgAACPskAAA98CYCGgQbLAgAGywMDBwsDBIdLAwVHiwMDR8sDA8gLAwUIQAQABoAJAAAPMssBAAALAwcFiwMHRcsDB4YLAwfGS8IgEYAGSYCHQQeLAgAHiwMDB8sDBIgLAwVISwMCCIsDBEjLAwUJAAQAB0AJAAAPgIsBAAALAwfGSwMIBosDCEbLAwiHCYCDAQdLAgAHSwMGR4sDBofLAwbICwMHCEsDBMiABAADAAkAAA5WCwEAAAAKAICEywNExImAhQEAgA4ExQMOg0ADAASIgAACcgoAgAMAMi717QKOAEMEiMCABIAAAnjIgAACrEsCAEMAAABAgEsDgcMLAgBEgAAAQIBLA4LEiwIARMAAAECASYCFADSLA4UEyYCFAQVLAgAFSwMDBYsDBIXLAwTGAAQABQAJAAAOyUsBAAAHgIADAkLKAAMgEYAEiMCABIAAApMJAAAPwguDAAJAAwmAhMEASYCFQQDADgTFRQsCAESABABFAEmAxIEAQAoEgIULA4TFAAoFAIULA4TFCYCFAQDADgSFBMsDBMULA4MFAAoEgIULA0UEyYCFQQCADgUFQw6DQAMABMiAAAKsSgCAAwAzeXfSQo4AQwSIwIAEgAACswiAAALmiwIAQwAAAECASwOBwwsCAESAAABAgEsDgsSLAgBEwAAAQIBJgIUAM4sDhQTJgIUBBUsCAAVLAwMFiwMEhcsDBMYABAAFAAkAAA7JSwEAAAeAgAMCQsoAAyARgASIwIAEgAACzUkAAA/Gi4IgEYADCYCEwQBJgIVBAMAOBMVFCwIARIAEAEUASYDEgQBACgSAhQsDhMUACgUAhQsDhMUJgIUBAMAOBIUEywMExQsDgwUACgSAhQsDRQTJgIVBAIAOBQVDDoNAAwAEyIAAAuaKAIADAArEbGaCjgBDBIjAgASAAALtSIAAAyoLAgBDAAAAQIBLA4HDCwIARIAAAECASwOCxIsCAETAAABAgEmAhQAyywOFBMmAhQEFSwIABUsDAwWLAwSFywMExgAEAAUACQAADslLAQAAB4CABQJCygAFIBGABUjAgAVAAAMHiQAAD8sJgIVBBYsCAAWLAwMFywMEhgsDBMZLAwFGgAQABUAJAAAO08sBAAALAwXFCYCEgQBJgIVBAMAOBIVEywIAQwAEAETASYDDAQBACgMAhMsDhITACgTAhMsDhITJgITBAMAOAwTEiwMEhMsDhQTACgMAhQsDRQTJgIVBAIAOBQVEjoNABIAEyIAAAyoKAIADACFMnbxCjgBDBIjAgASAAAMwyIAABKcJgIMBAQsCAESJgITBAUAEAETASYDEgQBACgSAhMfPAAGAAwAEywNEhMAKBMCEywOExIsCAETAAABAgEsDhITLAgBEgAAAQIBLA4EEiYCFQQWLAgAFiwMExcsDBIYLAwDGQAQABUAJAAAPz4sBAAALAwXFCYCFgQXLAgAFywMExgsDBIZLAwDGgAQABYAJAAAPz4sBAAALAwYFSYCFwQYLAgAGCwMExksDBIaLAwQGwAQABcAJAAAP+IsBAAALAwZFiYCGAQZLAgAGSwMExosDBIbLAwQHAAQABgAJAAAP+IsBAAALAwaFywIARIAAAECASwOBxIsCAETAAABAgEsDgsTLAgBGAAAAQIBJgIZALEsDhkYJgIZBBosCAAaLAwSGywMExwsDBgdABAAGQAkAAA7JSwEAAAeAgAZAQo4FBkaIwIAGgAAEcAiAAAOESwNEhksDRMaLA0YGx4CABwBLAgBHSYCHgQCABABHgEmAx0EAQAoHQIeHzwABAAGAB4sDR0eACgeAh4sDh4dACgdAh8AOB8EICwNIB4cDB4fBBwMHx0AJgIfBCAsCAAgLAwZISwMGiIsDBsjABAAHwAkAAAkmCwEAAAsDCEeJgIZAC0sCAEaJgIbBAUAEAEbASYDGgQBACgaAhssDBsfLA4ZHwAoHwIfLA4cHwAoHwIfLA4dHwAoHwIfLA4eHywNGhkAKBkCGSwOGRoqAgAZAAAAAAAAAAAEAAAAAAAAAAAmAh8EICwIACAsDBkhABAAHwAkAAA39ywEAAAsDCEbLAwiHCwMIx0sDCQeLA0bGQAoGQIZLA4ZGywIARkAAAECASwOGxksDRwbACgbAhssDhscLAgBGwAAAQIBLA4cGywIARwAAAECASwOHRwsCAEdAAABAgEsDh4dLAwEFyIAAA9yDDgXDB4jAgAeAAARUCIAAA+EJgIXBB4sCAAeLAwZHywMGyAsDBwhLAwdIgAQABcAJAAAOJ4sBAAALAwfDCgCABcAJxaxZiYCGgQDJgIcBAMAOBocGywIARkAEAEbASYDGQQBACgZAhssDhobACgbAhssDhobJgIbBAMAOBkbGiwMGhssDhcbACgbAhssDhQbACgbAhssDgwbLA0ZDAAoDAIMLA4MGSwIAQwmAhcEAwAQARcBJgMMBAEAKAwCFywMFxotCoBIABoAKBoCGi0KgEgAGgAoDAIXACgZAhwsDRwbJgIdBAIAOBwdGjgDpQAXgEYAGgAbABwgAgAMLAgBGQAoGQIdLA0dGyYCHgQCADgdHhohPAAEAAwAGiwMDBsmAh4EAwA4Gx4dABABHQEmAxkEAQAoGQIeLA4bHgAoHgIeLA4bHiwMGxcGKBcCFywNGQwAKAwCDCwODBkjAgAcAAAQ9iIAABDaACgZAhssDRsaJgIcBAIAOBscDDsNDBoiAAAQ9go4FwYMIwIADAAAEQgkAABAhgAoGQIXLA0XFww4BBcaIwIAGgAAESMkAABAmCYCGgQDADgZGhcAOBcEGiwNGgwLKAAMgEcAFyMCABcAABFLJAAAQKoiAAAR1yMCAB4AABFdIgAAEbImAh8EBAw4Fx8gIwIAIAAAEXQkAABAmAAoGgIfADgfFyAsDSAeJgIfBCAsCAAgLAwZISwMGyIsDBwjLAwdJCwMHiUAEAAfACQAAEC8LAQAACIAABGyADgXBh4sDB4XIgAAD3IKOBcLDCMCAAwAABHSJAAAQesiAAAR1yYCGwQcLAgAHCwMEh0sDBMeLAwYHywMCCAsDBEhLAwWIgAQABsAJAAAPgIsBAAALAwdDCwMHhcsDB8ZLAwgGiYCEwQbLAgAGywMDBwsDBcdLAwZHiwMGh8AEAATACQAADtPLAQAACwMHBIKOBIUEyMCABMAABJTJAAAQf0mAhIEGywIABssDAwcLAwXHSwMGR4sDBofLAwVIAAQABIAJAAAOVgsBAAAACgCAhMsDRMSJgIUBAIAOBMUDDoNAAwAEiIAABKcKAIADAAxmldRCjgBDBIjAgASAAAStyIAABaELAgBEiYCEwQOABABEwEmAxIEAQAoEgITHywABoBFABMsDRITACgTAhMsDhMSLAgBEwAAAQIBLAgBFAAAAQIBACgSAhYAOBYEFywNFxUsDhITLA4GFCwIARImAhYEBAAQARYBJgMSBAEAKBICFiwMFhcsDgsXACgXAhcsDgsXACgXAhcsDgsXLAgBFgAAAQIBLA4SFiwMBAwiAAATVA0oAAyAQwASIwIAEgAAIRUiAAATaSwNExIsDRQXASgAF4BDABgOOBcYGSMCABkAABOLJAAAQg8sDhITLA4YFCwNFhIAKBICFwA4FwQYLA0YFgAoEgIYADgYBhksDRkXACgSAhkAOBkOGiwNGhgcDBgZARwMGRIALAgBGCYCGQQKABABGQEmAxgEAQAoGAIZLAwZGiwOCxoAKBoCGiwOCxoAKBoCGiwOCxoAKBoCGiwOCxoAKBoCGiwOCxoAKBoCGiwOCxoAKBoCGiwOCxoAKBoCGiwOCxoAKBoCGiwOCxosCAEZAAABAgEsDhgZJgIYBAksDAQMIgAAFE4MOAwYGiMCABoAACB+IgAAFGAsDRMaLA0UGwA4GxgcDjgbHB0jAgAdAAAUfyQAAEIPLA4aEywOHBQsDRkTLA0TFAAoFAIULA4UEywIARQAAAECASwOExQsCAETAAABAgEsDgQTLAgBGSYCGgQKABABGgEmAxkEAQAoGQIaLAwaGywOCxsAKBsCGywOCxsAKBsCGywOCxsAKBsCGywOCxsAKBsCGywOCxsAKBsCGywOCxsAKBsCGywOCxsAKBsCGywOCxsAKBsCGywOCxsmAhsEHCwIABwsDBQdLAwTHiwMEB8sDBkgABAAGwAkAABCISwEAAAsDB0aLA0aEwAoEwITLA4TGiwIARMAAAECASwOBxMsCAEUAAABAgEsDgsULAgBGwAAAQIBJgIcAKAsDhwbJgIcBB0sCAAdLAwTHiwMFB8sDBsgABAAHAAkAAA7JSwEAAAeAgATAR4CABQACjgTFBsjAgAbAAAVvSQAAENyLAgBEyYCFAQEABABFAEmAxMEAQAoEwIULAwUGywOFhsAKBsCGywOFxsAKBsCGywOEhssDAQMIgAAFfgNKAAMgEMAEiMCABIAACA7IgAAFg0AOBUFEiwNGRMAKBMCEywOExksCAETAAABAgEsDhkTLAwEDCIAABY1DDgMGBQjAgAUAAAfwyIAABZHLA0TFCwMBAwiAAAWVAw4DBgTIwIAEwAAH4AiAAAWZgAoAgITLA0TEiYCFAQCADgTFAw6DQAMABIiAAAWhCgCAAwAIevl+Ao4AQwSJgIMAEsjAgASAAAWpCIAABhILAgBEiYCEwQDABABEwEmAxIEAQAoEgITHzwABgAOABMsDRITACgTAhMsDhMSLAgBEwAAAQIBLA4SEywIARIAAAECASwOBBImAhUEFiwIABYsDBMXLAwSGCwMEBkAEAAVACQAADwVLAQAACwMFxQmAhYEFywIABcsDBMYLAwSGSwMEBoAEAAWACQAADwVLAQAACwMGBUsCAESAAABAgEsDgcSLAgBEwAAAQIBLA4LEywIARYAAAECASYCFwCfLA4XFiYCFwQYLAgAGCwMEhksDBMaLAwWGwAQABcAJAAAOyUsBAAAHgIAFwEmAhgEGSwIABksDBcaLAwUGywMFRwsDBIdLAwTHiwMFh8sDBIgLAwTISwMFiItCIBGACMsDBIkLAwTJSwMFiYsDAknLAwSKCwMEyksDBYqLAwFKywMEiwsDBMtLAwWLiwMAy8sDAwwLAwSMSwMEzIsDBYzLAwNNCwMDzUsDBI2LAwTNywMFjgsDAg5LAwROgAQABgAJAAAQ4QsBAAAACgCAhQsDRQTJgIVBAIAOBQVEjoNABIAEyIAABhIKAIAEgAiArQ7CjgBEhMjAgATAAAYYyIAABpPLAgBEiYCEwQEABABEwEmAxIEAQAoEgITHywABoBDABMsDRITACgTAhMsDhMSLAgBEwAAAQIBLA4SEywIARIAAAECASwOBBImAhUEFiwIABYsDBMXLAwSGAAQABUAJAAATp4sBAAALAwXFAAoFAIWADgWBBcsDRcVJgIWBBcsCAAXLAwTGCwMEhksDBAaABAAFgAkAABPGSwEAAAsDBgUJgIXBBgsCAAYLAwTGSwMEhosDBAbABAAFwAkAABPGSwEAAAsDBkWLAgBEgAAAQIBLA4HEiwIARMAAAECASwOCxMsCAEXAAABAgEmAhgAcSwOGBcmAhgEGSwIABksDBIaLAwTGywMFxwAEAAYACQAADslLAQAAB4CABgBHgIAGQAKOBgZGiMCABoAABmUJAAAT70mAhgEGSwIABksDBUaLAwUGywMFhwsDBIdLAwTHiwMFx8sDBIgLAwTISwMFyItCIBGACMsDBIkLAwTJSwMFyYsDAknLAwSKCwMEyksDBcqLAwFKywMEiwsDBMtLAwXLiwMAy8sDAwwLAwSMSwMEzIsDBczLAwNNCwMDzUsDBI2LAwTNywMFzgsDAg5LAwROgAQABgAJAAAQ4QsBAAAACgCAgwsDQwJJgISBAIAOAwSBToNAAUACSIAABpPKAIABQAleEkUCjgBBQkjAgAJAAAaaiIAABvyLAgBBSYCCQQDABABCQEmAwUEAQAoBQIJHzwABgAOAAksDQUJACgJAgksDgkFLAgBCQAAAQIBLA4FCSwIAQUAAAECASwOBAUmAg4EEiwIABIsDAkTLAwFFCwMAxUAEAAOACQAADtxLAQAACwMEwwmAg4EEiwIABIsDAkTLAwFFCwMEBUAEAAOACQAADwVLAQAACwMEwMsCAEFAAABAgEsDgcFLAgBCQAAAQIBLA4LCSwIAQ4AAAECASYCEABiLA4QDiYCEAQSLAgAEiwMBRMsDAkULAwOFQAQABAAJAAAOyUsBAAAHgIAEAEeAgASAAo4EBITIwIAEwAAG2okAABPzyYCFQQWLAgAFiwMBRcsDAkYLAwOGSwMCBosDBEbLAwDHAAQABUAJAAAPgIsBAAALAwXECwMGBIsDBkTLAwaFCYCAwQVLAgAFSwMEBYsDBIXLAwTGCwMFBksDAwaABAAAwAkAAA5WCwEAAAAKAICCSwNCQUmAgwEAgA4CQwDOg0AAwAFIgAAG/IoAgACAPhBCA0KOAECAyMCAAMAABwNIgAAHi4sCAEBJgICBAIAEAECASYDAQQBACgBAgIfPAAGAAYAAiwNAQIAKAICAiwOAgEsCAECAAABAgEsDgECLAgBAQAAAQIBLA4EASYCBQQSLAgAEiwMAhMsDAEUABAABQAkAAA6qiwEAAAsDBMDACgDAgIAOAIEBSwNBQEsCAECAAABAgEsDgcCLAgBAwAAAQIBLA4LAywIAQUAAAECASYCCQAxLA4JBSYCCQQSLAgAEiwMAhMsDAMULAwFFQAQAAkAJAAAOyUsBAAAHgIACQkLKAAJgEYACyMCAAsAABzuJAAAT+EmAhAEEiwIABIsDAITLAwDFCwMBRUsDA0WLAwPFywMARgAEAAQACQAADzLLAQAACwMEwksDBQLLAwVDCwMFg4mAg8EEiwIABIsDAkTLAwLFCwMDBUsDA4WABAADwAkAAA90SwEAAAsDBMNIwIADQAAHWUkAABP8yYCDgQSLAgAEiwMAhMsDAMULAwFFSwMCBYsDBEXLAwBGAAQAA4AJAAAPgIsBAAALAwTCSwMFAssDBUMLAwWDSYCAgQOLAgADiwMCQ8sDAsQLAwMESwMDRIAEAACACQAADtPLAQAACwMDwEmAgMEASYCCAQDADgDCAUsCAECABABBQEmAwIEAQAoAgIFLA4DBQAoBQIFLA4DBSYCBQQDADgCBQMsDAMFLA4BBQAoAgIFLA0FAyYCCAQCADgFCAE6DQABAAMiAAAeLiYCAQJsJgICAmsmAgMCYyYCBQJvJgIGAnQmAggCdyYCCQIgJgILAnImAgwCcyYCDQJVJgIOAmUmAg8CbiwIARAmAhEEEQAQAREBJgMQBAEAKBACESwMERIsDg0SACgSAhIsDg8SACgSAhIsDgISACgSAhIsDg8SACgSAhIsDgUSACgSAhIsDggSACgSAhIsDg8SACgSAhIsDgkSACgSAhIsDgwSACgSAhIsDg4SACgSAhIsDgESACgSAhIsDg4SACgSAhIsDgMSACgSAhIsDgYSACgSAhIsDgUSACgSAhIsDgsSCjgHCgEjAgABAAAffyYCAgQSLAgBAyYCBQQSABABBQEsDAMFKQMABQXlj5hZBzFikAAoBQIFACgQAgYmAggEEC0EAAaAAy0EAAWABC0EAAiABSQAAFAFJgIGBBAAOAUGBSwOBAUAKAUCBTsNAwIlHAwMEwAAOBITFSYCFgQJDDgMFhcjAgAXAAAfoSQAAECYACgUAhYAOBYMFywNFxMvDAATABUAOAwGEywMEwwiAAAWVCYCFQQJDDgMFRYjAgAWAAAf2iQAAECYACgaAhUAOBUMFiwNFhQsDRMVJgIXBAkMOAwXGSMCABkAACADJAAAQJgtBAAVgAMnAIAEBAAKJAAAUEstCIAFABYAKBYCFwA4FwwZLA4UGSwOFhMAOAwGFCwMFAwiAAAWNRwMDBIAADgVEhQmAhYEAww4DBYXIwIAFwAAIFwkAABAmAAoEwIWADgWDBcsDRcSLwwAEgAUADgMBhIsDBIMIgAAFfgsDRkaLA0TGywNFBwAOBwMHQ44HB0eIwIAHgAAIKEkAABCDyYCHgQNDDgdHh8jAgAfAAAguCQAAECYACgbAh4AOB4dHywNHxwmAh0ECQw4DB0eIwIAHgAAIN0kAABAmC0EABqAAycAgAQEAAokAABQSy0IgAUAGwAoGwIdADgdDB4sDhweLA4bGQA4DAYaLAwaDCIAABROLA0WEiwNExcsDRQYADgYDBkOOBgZGiMCABoAACE4JAAAQg8mAhoEDQw4GRobIwIAGwAAIU8kAABAmAAoFwIaADgaGRssDRsYJgIZBAMMOAwZGiMCABoAACF0JAAAQJgtBAASgAMnAIAEBAAEJAAAUEstCIAFABcAKBcCGQA4GQwaLA4YGiwOFxYAOAwGEiwMEgwiAAATVCMCABkAACG5IgAAIg4mAhoEAww4AxobIwIAGwAAIdAkAABAmAAoFwIaADgaAxssDRsZJgIaBBssCAAbLAwTHCwMFB0sDBUeLAwYHywMGSAAEAAaACQAAEC8LAQAACIAACIOADgDBhksDBkDIgAABAknAIAEBHgADQAAAIAEgAMjAIADAAAiRCkBAAEF96Hzr6Wt1Mo7AQECJSQAACIcJgIFAAAsCAEGJgIHBCAAEAEHASYDBgQBACgGAgcmAggEHwA4CAcILAwHCQw4CQgKFgwKCiMCAAoAACKULA4FCQAoCQIJIgAAInUsCAEFAAABAgEsDgYFJgIGBB8mAgcEASYCCAQALAwIBCIAACK5DDgEBgMjAgADAAAkASIAACLLLA0BBCwNAgkAOAkGCg44CQoLIwIACwAAIuokAABCDywOBAEsDgoCLA0FASYCAgIALAgBBCYCBQQgABABBQEmAwQEAQAoBAIFJgIJBB8AOAkFCSwMBQoMOAoJCxYMCwsjAgALAAAjQCwOAgoAKAoCCiIAACMhLAgBAgAAAQIBLA4EAiwMCAMiAAAjVgw4AwYEIwIABAAAI3oiAAAjaCwNAgEsDQECACgCAgIsDgIBJSwNAgQmAggEHww4AwgJIwIACQAAI5UkAABAmAAoAQIIADgIAwksDQkFHAwFCQIcDAkIABwMCAUCJgIJBB8MOAMJCiMCAAoAACPJJAAAQJgtBAAEgAMnAIAEBAAgJAAAUEstCIAFAAgAKAgCCQA4CQMKLA4FCiwOCAIAOAMHBCwMBAMiAAAjViwNBQMsDQEJLA0CCgA4CgQLDjgKCwwjAgAMAAAkJCQAAEIPJgIMBD8MOAsMDSMCAA0AACQ7JAAAQJgAKAkCDAA4DAsNLA0NCiYCCwQfDDgECwwjAgAMAAAkYCQAAECYLQQAA4ADJwCABAQAICQAAFBLLQiABQAJACgJAgsAOAsEDCwOCgwsDgkFADgEBwMsDAMEIgAAIrkkAAAiHCwIAQQAAAECASwOAQQsCAEFAAABAgEsDgIFIwIAAQAAN/IiAAAkxCYCAgAxCjgDAgYqAgACAAAAAAAAAAACAAAAAAAAAAAmAgcEASYCCAAsJgIJBAImAgoEACMCAAYAADZRIgAAJQQmAgYAYgo4AwYLKgIABgAAAAAAAAAAAwAAAAAAAAAAIwIACwAANJsiAAAlMCYCCwBxCjgDCwwmAgsEBCMCAAwAADKvIgAAJUwmAgwAlgo4AwwNJgIMAAAjAgANAAAypiIAACVoJgINAJ8KOAMNDiMCAA4AADDwIgAAJX8mAg0AoAo4Aw0OIwIADgAALm4iAAAlliYCDQCxCjgDDQ4jAgAOAAAscCIAACWtJgILAMsKOAMLDSMCAA0AACxMIgAAJcQmAgsAzgo4AwsNIwIADQAALCgiAAAl2yYCCwDSCjgDCw0jAgANAAAsBCIAACXyJgILANMKOAMLDCMCAAwAACpOIgAAJgkmAgYA2Ao4AwYLIwIACwAAKL8iAAAmICYCBgDZCjgDBgkjAgAJAAAmOyYCCwQAOwkBCyYCAwQ/LAgBBiYCCQRAABABCQEmAwYEAQAoBgIJHzwABwADAAksCAEJJgILBEEAEAELASYDCQQBACgJAgsmAgwEQAA4DAsMLAwLDQw4DQwOFgwODiMCAA4AACalLA4IDQAoDQINIgAAJoYsCAEIAAABAgEsDgkILAwKAiIAACa7DDgCAwkjAgAJAAAoMCIAACbNLA0IAywNAwYAKAYCBiwOBgMqAgAGAAAAAAAAAABAAAAAAAAAAAAmAg0EDiwIAA4sDAYPABAADQAkAAA39ywEAAAsDA8ILAwQCSwMEQssDBIMLA0IBgAoBgIGLA4GCCwIAQYAAAECASwOCAYsDQkIACgIAggsDggJLAgBCAAAAQIBLA4JCCwIAQkAAAECASwOCwksCAELAAABAgEsDgwLJgIMBEAsDAoCIgAAJ3oMOAIMCiMCAAoAACfAIgAAJ4wmAgMEDCwIAAwsDAYNLAwIDiwMCQ8sDAsQABAAAwAkAAA4niwEAAAsDA0CLAwCASIAADdwIwIACgAAJ80iAAAoIiYCDQRADDgCDQ4jAgAOAAAn5CQAAECYACgDAg0AOA0CDiwNDgomAg0EDiwIAA4sDAYPLAwIECwMCREsDAsSLAwKEwAQAA0AJAAAQLwsBAAAIgAAKCIAOAIHCiwMCgIiAAAneiwNCAkAOAIHCw44AgsMIwIADAAAKEskAABCDyYCDQQ/DDgCDQ4jAgAOAAAoYiQAAECYACgGAg0AOA0CDiwNDgwmAg4EQAw4Cw4PIwIADwAAKIckAABAmC0EAAmAAycAgAQEAEEkAABQSy0IgAUADQAoDQIOADgOCw8sDgwPLA4NCAA4AgcJLAwJAiIAACa7LAgBBiYCCwQCABABCwEmAwYEAQAoBgILHzwABwAHAAsAKAYCDAA4DAoNLA0NCywIAQYmAgwEAwAQAQwBJgMGBAEAKAYCDCwMDA0sDggNACgNAg0sDgsNJgIOBA8sCAAPLAwCEAAQAA4AJAAAN/csBAAALAwQCCwMEQssDBIMLAwTDSwNCAIAKAICAiwOAggsCAECAAABAgEsDggCLA0LCAAoCAIILA4ICywIAQgAAAECASwOCwgsCAELAAABAgEsDgwLLAgBDAAAAQIBLA4NDCwMCgMiAAApmAw4AwkKIwIACgAAKd4iAAApqiYCBgQNLAgADSwMAg4sDAgPLAwLECwMDBEAEAAGACQAADieLAQAACwMDgMsDAMBIgAAN3AjAgAKAAAp6yIAACpAJgINBAIMOAMNDiMCAA4AACoCJAAAQJgAKAYCDQA4DQMOLA0OCiYCDQQOLAgADiwMAg8sDAgQLAwLESwMDBIsDAoTABAADQAkAABAvCwEAAAiAAAqQAA4AwcKLAwKAyIAACmYLAgBAyYCCwQDABABCwEmAwMEAQAoAwILHzwABwAJAAsAKAMCCwA4CwoMLA0MCQAoAwIMADgMBw0sDQ0LLAgBAyYCDAQEABABDAEmAwMEAQAoAwIMLAwMDSwOCA0AKA0CDSwOCQ0AKA0CDSwOCw0sDQMIACgIAggsDggDJgINBA4sCAAOLAwGDwAQAA0AJAAAN/csBAAALAwPCCwMEAksDBELLAwSDCwNCAYAKAYCBiwOBggsCAEGAAABAgEsDggGLA0JCAAoCAIILA4ICSwIAQgAAAECASwOCQgsCAEJAAABAgEsDgsJLAgBCwAAAQIBLA4MCywMCgIiAAArSw0oAAKAQwAKIwIACgAAK5QiAAArYCYCAwQMLAgADCwMBg0sDAgOLAwJDywMCxAAEAADACQAADieLAQAACwMDQIsDAIBIgAAN3AjAgAKAAAroSIAACv2JgIMBAMMOAIMDSMCAA0AACu4JAAAQJgAKAMCDAA4DAINLA0NCiYCDAQNLAgADSwMBg4sDAgPLAwJECwMCxEsDAoSABAADAAkAABAvCwEAAAiAAAr9gA4AgcKLAwKAiIAACtLLAgBAgAAAQIBJgMCBAEAKAICAx88AAcACgADLAwMASIAADdwLAgBAgAAAQIBJgMCBAEAKAICAx88AAcACgADLAwMASIAADdwLAgBAgAAAQIBJgMCBAEAKAICAx88AAcACgADLAwMASIAADdwLAgBAyYCBgQFABABBgEmAwMEAQAoAwIGHzwABwALAAYsDQMGACgGAgYsDgYDACgDAgsAOAsKDCwNDAYAKAMCDAA4DAcNLA0NCwAoAwINADgNCQ4sDQ4MACgDAg0BKAANgEMADiwNDgksCAEDJgINBAYAEAENASYDAwQBACgDAg0sDA0OLA4IDgAoDgIOLA4GDgAoDgIOLA4LDgAoDgIOLA4MDgAoDgIOLA4JDioCAAYAAAAAAAAAAAUAAAAAAAAAACYCDQQOLAgADiwMBg8AEAANACQAADf3LAQAACwMDwgsDBAJLAwRCywMEgwsDQgGACgGAgYsDgYILAgBBgAAAQIBLA4IBiwNCQgAKAgCCCwOCAksCAEIAAABAgEsDgkILAgBCQAAAQIBLA4LCSwIAQsAAAECASwODAsmAgwEBSwMCgIiAAAtuAw4AgwKIwIACgAALf4iAAAtyiYCAwQMLAgADCwMBg0sDAgOLAwJDywMCxAAEAADACQAADieLAQAACwMDQIsDAIBIgAAN3AjAgAKAAAuCyIAAC5gJgINBAUMOAINDiMCAA4AAC4iJAAAQJgAKAMCDQA4DQIOLA0OCiYCDQQOLAgADiwMBg8sDAgQLAwJESwMCxIsDAoTABAADQAkAABAvCwEAAAiAAAuYAA4AgcKLAwKAiIAAC24LAgBAyYCBgQOABABBgEmAwMEAQAoAwIGHywAB4BFAAYsCAEGJgIJBA8AEAEJASYDBgQBACgGAgkmAgsEDgA4CwkLLAwJDAw4DAsNFgwNDSMCAA0AAC7TLA4IDAAoDAIMIgAALrQsCAEIAAABAgEsDgYILAwKAiIAAC7pDSgAAoBFAAYjAgAGAAAwYSIAAC7+LA0IAywNAwYAKAYCBiwOBgMqAgAGAAAAAAAAAAAOAAAAAAAAAAAmAg0EDiwIAA4sDAYPABAADQAkAAA39ywEAAAsDA8ILAwQCSwMEQssDBIMLA0IBgAoBgIGLA4GCCwIAQYAAAECASwOCAYsDQkIACgIAggsDggJLAgBCAAAAQIBLA4JCCwIAQkAAAECASwOCwksCAELAAABAgEsDgwLJgIMBA4sDAoCIgAAL6sMOAIMCiMCAAoAAC/xIgAAL70mAgMEDCwIAAwsDAYNLAwIDiwMCQ8sDAsQABAAAwAkAAA4niwEAAAsDA0CLAwCASIAADdwIwIACgAAL/4iAAAwUyYCDQQODDgCDQ4jAgAOAAAwFSQAAECYACgDAg0AOA0CDiwNDgomAg0EDiwIAA4sDAYPLAwIECwMCREsDAsSLAwKEwAQAA0AJAAAQLwsBAAAIgAAMFMAOAIHCiwMCgIiAAAvqywNCAYAOAIHCQ44AgkLIwIACwAAMHwkAABCDyYCDAQNDDgCDA0jAgANAAAwkyQAAECYACgDAgwAOAwCDSwNDQsmAg0EDgw4CQ0OIwIADgAAMLgkAABAmC0EAAaAAycAgAQEAA8kAABQSy0IgAUADAAoDAINADgNCQ4sDgsOLA4MCAA4AgcGLAwGAiIAAC7pLAgBAyYCCwQDABABCwEmAwMEAQAoAwILHzwABwAJAAsAKAMCCwA4CwoMLA0MCQAoAwIMADgMBw0sDQ0LLAgBAyYCDAQEABABDAEmAwMEAQAoAwIMLAwMDSwOCA0AKA0CDSwOCQ0AKA0CDSwOCw0sDQMIACgIAggsDggDJgINBA4sCAAOLAwGDwAQAA0AJAAAN/csBAAALAwPCCwMEAksDBELLAwSDCwNCAYAKAYCBiwOBggsCAEGAAABAgEsDggGLA0JCAAoCAIILA4ICSwIAQgAAAECASwOCQgsCAEJAAABAgEsDgsJLAgBCwAAAQIBLA4MCywMCgIiAAAx7Q0oAAKAQwAKIwIACgAAMjYiAAAyAiYCAwQMLAgADCwMBg0sDAgOLAwJDywMCxAAEAADACQAADieLAQAACwMDQIsDAIBIgAAN3AjAgAKAAAyQyIAADKYJgIMBAMMOAIMDSMCAA0AADJaJAAAQJgAKAMCDAA4DAINLA0NCiYCDAQNLAgADSwMBg4sDAgPLAwJECwMCxEsDAoSABAADAAkAABAvCwEAAAiAAAymAA4AgcKLAwKAiIAADHtLAwMASIAADdwLAgBAyYCBgQEABABBgEmAwMEAQAoAwIGHywAB4BDAAYsDQMGACgGAgYsDgYDACgDAgwAOAwKDSwNDQYAKAMCDQA4DQcOLA0ODAAoAwIOADgOCQ8sDQ8NLAgBAyYCCQQFABABCQEmAwMEAQAoAwIJLAwJDiwOCA4AKA4CDiwOBg4AKA4CDiwODA4AKA4CDiwODQ4sDQMGACgGAgYsDgYDKgIABgAAAAAAAAAABAAAAAAAAAAAJgIOBA8sCAAPLAwGEAAQAA4AJAAAN/csBAAALAwQCCwMEQksDBIMLAwTDSwNCAYAKAYCBiwOBggsCAEGAAABAgEsDggGLA0JCAAoCAIILA4ICSwIAQgAAAECASwOCQgsCAEJAAABAgEsDgwJLAgBDAAAAQIBLA4NDCwMCgIiAAAz5Qw4AgsKIwIACgAANCsiAAAz9yYCAwQNLAgADSwMBg4sDAgPLAwJECwMDBEAEAADACQAADieLAQAACwMDgIsDAIBIgAAN3AjAgAKAAA0OCIAADSNJgINBAQMOAINDiMCAA4AADRPJAAAQJgAKAMCDQA4DQIOLA0OCiYCDQQOLAgADiwMBg8sDAgQLAwJESwMDBIsDAoTABAADQAkAABAvCwEAAAiAAA0jQA4AgcKLAwKAiIAADPlLAgBAyYCCwQDABABCwEmAwMEAQAoAwILHzwABwAJAAsAKAMCCwA4CwoMLA0MCQAoAwIMADgMBw0sDQ0LLAgBAyYCDAQEABABDAEmAwMEAQAoAwIMLAwMDSwOCA0AKA0CDSwOCQ0AKA0CDSwOCw0sDQMIACgIAggsDggDJgINBA4sCAAOLAwGDwAQAA0AJAAAN/csBAAALAwPCCwMEAksDBELLAwSDCwNCAYAKAYCBiwOBggsCAEGAAABAgEsDggGLA0JCAAoCAIILA4ICSwIAQgAAAECASwOCQgsCAEJAAABAgEsDgsJLAgBCwAAAQIBLA4MCywMCgIiAAA1mA0oAAKAQwAKIwIACgAANeEiAAA1rSYCAwQMLAgADCwMBg0sDAgOLAwJDywMCxAAEAADACQAADieLAQAACwMDQIsDAIBIgAAN3AjAgAKAAA17iIAADZDJgIMBAMMOAIMDSMCAA0AADYFJAAAQJgAKAMCDAA4DAINLA0NCiYCDAQNLAgADSwMBg4sDAgPLAwJECwMCxEsDAoSABAADAAkAABAvCwEAAAiAAA2QwA4AgcKLAwKAiIAADWYLAgBBiYCCwQCABABCwEmAwYEAQAoBgILHzwABwAHAAsAKAYCDAA4DAoNLA0NCywIAQYmAgwEAwAQAQwBJgMGBAEAKAYCDCwMDA0sDggNACgNAg0sDgsNJgIOBA8sCAAPLAwCEAAQAA4AJAAAN/csBAAALAwQCCwMEQssDBIMLAwTDSwNCAIAKAICAiwOAggsCAECAAABAgEsDggCLA0LCAAoCAIILA4ICywIAQgAAAECASwOCwgsCAELAAABAgEsDgwLLAgBDAAAAQIBLA4NDCwMCgMiAAA3Kgw4AwkKIwIACgAAN4IiAAA3PCYCBgQNLAgADSwMAg4sDAgPLAwLECwMDBEAEAAGACQAADieLAQAACwMDgMsDAMBIgAAN3AmAgIBASwOAgQsDgEFIgAAN/IjAgAKAAA3jyIAADfkJgINBAIMOAMNDiMCAA4AADemJAAAQJgAKAYCDQA4DQMOLA0OCiYCDQQOLAgADiwMAg8sDAgQLAwLESwMDBIsDAoTABAADQAkAABAvCwEAAAiAAA35AA4AwcKLAwKAyIAADcqLA0FASUkAAAiHCYCAgAALAgBAyYCBAQEABABBAEmAwMEAQAoAwIELAwEBSwOAgUAKAUCBSwOAgUAKAUCBSwOAgUsDQMEACgEAgQsDgQDLAgBBCYCBQQFABABBQEmAwQEAQAoBAIFLAwFBiwOAgYAKAYCBiwOAgYAKAYCBiwOAgYAKAYCBiwOAQYmAgEEACYCAgEALAwCBSwMAQYsDAQCLAwFBCwMAwEsDAYDJSQAACIcLA0EBSYCBgEACjgFBgcjAgAHAAA4wiYCCAQAOwkBCCYCBQQGLAgABiwMAQcsDAIILAwDCSwMBAoAEAAFACQAAFDZLAQAACwNAQUsDQIGLA0DBywOBQEsDgYCLA4HAyYCAQEBLA4BBCYCAQQAACgGAgMAOAMBBCwNBAIsDAIBJSkBAAEF9IABplnTJ0I7AQECJSkBAAEFHwBQEkAkIu47AQECJSkBAAEFBQ+GBCPtFlk7AQECJSQAACIcLwwABQAEJSQAACIcLAgBBAAAAQIBJgIFAAAsDgUELAgBBQAAAQIBLQqARgAFJgIGBAAnAgAHAAEAJgIIBB8mAgkEASwMBgMiAAA5qQw4AwgGIwIABgAAOcAiAAA5uywNBAElLAgBBgAAAQIBLA4DBiMCAAIAADnaIgAAOhECOAgDCg44AwgLIwIACwAAOfEkAABSNgI4CgkLDjgJCgwjAgAMAAA6CCQAAFI2LA4LBiIAADoRLA0ECiwNBgsmAgwEHww4CwwNIwIADQAAOjAkAABAmAAoAQIMADgMCw0sDQ0GHAwGCwAsDQUGBDgLBgwAOAoMCywOCwQEOAYHCiwOCgUAOAMJBiwMBgMiAAA5qSQAACIcATCARAAEAAYuDAAGAAcmAggAAAo4BwgJIwIACQAAOpYkAABSSCcCAAcA3q0vDAAHAAYvDAAFAAQlJAAAIhwsDQEDLA0CBCYCBgQBDDgEBgcjAgAHAAA6ziQAAECYACgDAgYAOAYEBywNBwUsCAEGJgIHBAIAEAEHASYDBgQBACgGAgcsDAcILA4FCCYCBQQBADgEBQcOOAQHCCMCAAgAADsYJAAAQg8sDgMBLA4HAiwMBgElJAAAIhweAgAEAB4CAAUAMjgABAAFAAYmAgQBASMCAAYAADtOJAAAUlolJAAAIhwuDAAEAAUsDAUBJSkBAAEFedUGXr5zdNI7AQECJSQAACIcJgIGBAcsCAAHLAwBCCwMAgkAEAAGACQAAFJsLAQAACwMCAUmAgEABAo4AwECJgIBBAAAKAUCBwA4BwEILA0IBiMCAAIAADwHIgAAO8MmAgEAEQo4AwECIwIAAgAAO/4iAAA72iYCAQCCCjgDAQIjAgACAAA79SYCBQQAOwkBBSwMBgQiAAA8ECwMBgQiAAA8ECwMBgQiAAA8ECwMBAElJAAAIhwmAgYEBywIAAcsDAEILAwCCQAQAAYAJAAAUmwsBAAALAwIBSYCAQAECjgDAQImAgEEAAAoBQIHADgHAQgsDQgGIwIAAgAAPKsiAAA8ZyYCAQARCjgDAQIjAgACAAA8oiIAADx+JgIBAIIKOAMBAiMCAAIAADyZJgIFBAA7CQEFLAwGBCIAADy0LAwGBCIAADy0LAwGBCIAADy0LAwEASUpAQABBVpra02Ieh9nOwEBAiUkAAAiHCYCDAQNLAgADSwMBA4sDAYPABAADAAkAABS5ywEAAAsDA4LJgIEAEsKOAUEBiYCBAAACjgLBAwmAgQBACMCAAYAAD2ZIgAAPRkmAgYATQo4BQYNIwIADQAAPXIiAAA9MCYCBgBPCjgFBg0jAgANAAA9SyYCDgQAOwkBDgo4DAQFIwIABQAAPV0kAABUbSwMAQcsDAIILAwDCSwMCwoiAAA9wAo4DAQFIwIABQAAPYQkAABUbSwMAQcsDAIILAwDCSwMCwoiAAA9wAo4DAQFIwIABQAAPaskAABUbSwMAQcsDAIILAwDCSwMCwoiAAA9wCwMCgQsDAcBLAwIAiwMCQMlJAAAIhwuDAAEAAUcDAUGARwMBgQAHAwEBQEsDAUBJSkBAAEFgQQVnu3WRdI7AQECJSQAACIcJgIMBA0sCAANLAwEDiwMBg8AEAAMACQAAFLnLAQAACwMDgsmAgQASwo4BQQGJgIEAAAKOAsEDCYCBAEAIwIABgAAPtAiAAA+UCYCBgBNCjgFBg0jAgANAAA+qSIAAD5nJgIGAE8KOAUGDSMCAA0AAD6CJgIOBAA7CQEOCjgMBAUjAgAFAAA+lCQAAFRtLAwBBywMAggsDAMJLAwLCiIAAD73CjgMBAUjAgAFAAA+uyQAAFRtLAwBBywMAggsDAMJLAwLCiIAAD73CjgMBAUjAgAFAAA+4iQAAFRtLAwBBywMAggsDAMJLAwLCiIAAD73LAwKBCwMBwEsDAgCLAwJAyUpAQABBftC3tO8Eo0COwEBAiUpAQABBdBN6s+si/1jOwEBAiUpAQABBYuNKgtyIlJQOwEBAiUkAAAiHCYCBgQHLAgABywMAQgsDAIJABAABgAkAABUfywEAAAsDAgFJgIBAAQKOAMBAiYCAQQAACgFAgcAOAcBCCwNCAYjAgACAAA/1CIAAD+QJgIBABEKOAMBAiMCAAIAAD/LIgAAP6cmAgEAggo4AwECIwIAAgAAP8ImAgUEADsJAQUsDAYEIgAAP90sDAYEIgAAP90sDAYEIgAAP90sDAQBJSQAACIcJgIGBAcsCAAHLAwBCCwMAgkAEAAGACQAAFR/LAQAACwMCAUmAgEABAo4AwECJgIBBAAAKAUCBwA4BwEILA0IBiMCAAIAAEB4IgAAQDQmAgEAEQo4AwECIwIAAgAAQG8iAABASyYCAQCCCjgDAQIjAgACAABAZiYCBQQAOwkBBSwMBgQiAABAgSwMBgQiAABAgSwMBgQiAABAgSwMBAElKQEAAQUNCi7y9sL77zsBAQIlKQEAAQXonQn+oREtDjsBAQIlKQEAAQVEjaopoqFAtzsBAQIlJAAAIhwsDQMGLA0EByYCCAEACjgHCAkjAgAJAABA5CYCCgQAOwkBCgsoAAaAQwAHJgIGBAEjAgAHAABBdyIAAED+LA0BBywNAggsDQMJLA0ECiYCDAQDDDgJDA0jAgANAABBJSQAAECYLQQAB4ADJwCABAQABCQAAFBLLQiABQALACgLAgwAOAwJDSwOBQ0AOAkGBQ44CQUHIwIABwAAQWIkAABCDywOCwEsDggCLA4FAywOCgQiAABB6iYCBwQILAgACCwMAQksDAIKLAwDCywMBAwAEAAHACQAAFDZLAQAACwNAQcsDQIILA0ECSYCCgQALQQAB4ADJwCABAQABCQAAFBLLQiABQALACgLAgwAOAwKDSwOBQ0sDgsBLA4IAiwOBgMsDgkEIgAAQeolKQEAAQWMnRG0OfRmkDsBAQIlKQEAAQWWhy8mBDX09jsBAQIlKQEAAQVFp8pxGUHkFTsBAQIlJAAAIhwsDQQGACgGAgYsDgYELAgBBgAAAQIBLA4EBiYCBAAECjgDBAcmAgQAEQo4AwQIJgIEBAkmAgkEACYCCgQBJgILAIIsDAkFIgAAQnEMOAUECSMCAAkAAEKIIgAAQoMsDQYBJSwNBgwsDQENLA0CDiYCEAQJDDgOEBEjAgARAABCqyQAAECYACgNAhAAOBAOESwNEQ8AOA4KEA44DhARIwIAEQAAQtAkAABCDywODQEsDhACIwIABwAAQxoiAABC5SMCAAgAAEMRIgAAQvIKOAMLDSMCAA0AAEMIJgIOBAA7CQEOLAwPCSIAAEMjLAwPCSIAAEMjLAwPCSIAAEMjJgIOBAkMOAUODyMCAA8AAEM6JAAAQJgtBAAMgAMnAIAEBAAKJAAAUEstCIAFAA0AKA0CDgA4DgUPLA4JDwA4BQoJLA4NBiwMCQUiAABCcSkBAAEF61c5A+igdoM7AQECJSQAACIcJgInBCgsCAAoLAwdKSwMHiosDB8rLAwgLCwMIS0sDAIuABAAJwAkAAA+AiwEAAAsDCkjLAwqJCwMKyUsDCwmJgIeBCcsCAAnLAwjKCwMJCksDCUqLAwmKwAQAB4AJAAAO08sBAAALAwoHQo4HQEeIwIAHgAARAUkAABU+iYCAQAAJgIdBCcsCAAnLAwjKCwMJCksDCUqLAwmKywMASwAEAAdACQAADlYLAQAACYCHQADADgDHR4sCAEdJgIfBAQAEAEfASYDHQQBACgdAh8sDB8gLA4BIAAoIAIgLA4BIAAoIAIgLA4BICwIAR8AAAECASwOHR8mAh0EACYCIAQBLAwdIiIAAESRDSgAIoBDAAQjAgAEAABOOyIAAESmLA0fBgAoBgIIADgIHQksDQkHACgGAgkAOAkgCiwNCggmAgkEAgAoBgILADgLCQwsDQwKHAwKCwEcDAsGABwMBgoBFgwKBgo4BwELBDgGCwwKOAgBCwQ4DAsNJgILAQAKOA0LDCMCAAwAAEUXJAAAVQwrAgAMACglx5zGpcu+731qjxtqErMSqjOEQK7+tDlhSMiRR8BJKwIADQASm/0dpUtwYta1ROfja5BzY1D2+6ASKMQccgmVCfVwHiwIAQ4mAg8EBAAQAQ8BJgMOBAEAKA4CDywMDxAsDgwQACgQAhAsDg0QACgQAhAsDgsQHAwCDQUcDA0MAAI4AgwNCSgADYBKAA8cDA8QBRwMEA0AAjgPDRAJKAAQgEoADwUoAA2ASgAQADgQDA0FMIBJAA8ADAA4DQwQCjgCEAwjAgAMAABF8SYCEQQAOwkBESwIAQwmAhAEAwAQARABJgMMBAEAKAwCECwMEBEsDg0RACgRAhEsDg8RLAgBDSYCDwQEABABDwEmAw0EAQAoDgIPJgIQBAMAKAwCESYCEgQCACgNAhNC9wAPABEAEwAQACgNAg4AOA4dDywNDwwAKA0CDwA4DyAQLA0QDgAoDQIQADgQCREsDREPHAwPDQEcDA0JABwMCQ0BCjgMBwkKOA4IDwQ4CQ8QFgwPEQQ4CREPHAwJEQAAOAwREiwIAREmAhMEBAAQARMBJgMRBAEAKBECE0E/wAASAA4ACQAHAAgACgATACgRAhMAOBMdFCwNFBIAKBECFAA4FCAVLA0VEywIAREAAAECASwIARQAAAECASwIARUAAAECASwOEhEsDhMULA4JFSwIARYmAhcEBAAQARcBJgMWBAEAKBYCF0E/wAAMAA4ADQAMAA4ADQAXACgWAhgAOBgdGSwNGRcAKBYCGQA4GSAaLA0aGCMCABAAAEd6IgAAR2ksDBIDLAwTBCwMCQUiAABHiywMFwMsDBgELAwLBSIAAEeLLA4DESwOBBQsDgUVIwIADQAAR6QiAABHtSwOBxEsDggULA4KFSIAAEe1IwIACgAAR8IiAABH0ywODBEsDg4ULA4NFSIAAEfTFgwNBAQ4BAYFBDgPBQQsDREFLA0UBgQ4DQoHEjgEBwgsDgURLA4GFCwOCBUxAgAFLAgBBCYCBQQKABABBQEmAwQEAQAoBAIFLAwFBiwOAQYAKAYCBiwOAQYAKAYCBiwOAQYAKAYCBiwOAQYAKAYCBiwOAQYAKAYCBiwOAQYAKAYCBiwOAQYAKAYCBiwOAQYAKAYCBiwOAQYsCAEFAAABAgEsDgQFJgIEBAksDB0DIgAASIYMOAMEBiMCAAYAAE3YIgAASJgsDQUGLA0GBQAoBQIFLA4FBiwIAQUAAAECASwOBgUsCAEGAAABAgEsDh0GLAgBByYCCAQKABABCAEmAwcEAQAoBwIILAwICSwOAQkAKAkCCSwOAQkAKAkCCSwOAQkAKAkCCSwOAQkAKAkCCSwOAQkAKAkCCSwOAQkAKAkCCSwOAQkAKAkCCSwOAQkAKAkCCSwOAQkmAggAgiYCCgQhLAgAISwMBSIsDAYjLAwIJCwMByUAEAAKACQAAEIhLAQAACwMIgksDQkFACgFAgUsDgUJLAgBBSYCBgQMABABBgEmAwUEAQAoBQIGJgIHBAsAOAcGBywMBggMOAgHChYMCgojAgAKAABJrSwOAQgAKAgCCCIAAEmOLAgBBgAAAQIBLA4FBiYCBQIJJgIHAgEmAggCACwIAQomAgsEBgAQAQsBJgMKBAEAKAoCCywMCwwsDggMACgMAgwsDgcMACgMAgwsDggMACgMAgwsDggMACgMAgwsDgUMLAgBBQAAAQIBLA4BBSwIAQcAAAECAS0KgEYABycCAAgAAQAmAgsEBSwMHQMiAABKPgw4AwsMIwIADAAATVMiAABKUCwNBQcsCAEFJgIIBAwAEAEIASYDBQQBACgFAggsDAgKLA4HCgAoCgIKLA4BCgAoCgIKLA4BCgAoCgIKLA4BCgAoCgIKLA4BCgAoCgIKLA4BCgAoCgIKLA4BCgAoCgIKLA4BCgAoCgIKLA4BCgAoCgIKLA4BCgAoCgIKLA4BCiwOBQYsCAEFAAABAgEsDiAFLAwdAyIAAEroDDgDBAcjAgAHAABMwCIAAEr6LA0FBwA4BwQIDjgHCAkjAgAJAABLFSQAAEIPLA4IBSwNBgQmAgcECww4CAcJIwIACQAASzQkAABAmC0EAASAAycAgAQEAAwkAABQSy0IgAUABQAoBQIHADgHCAksDgIJLA4FBiwIAQImAgQEDAAQAQQBJgMCBAEAKAICBCYCBgQLADgGBAYsDAQHDDgHBggWDAgIIwIACAAAS6MsDgEHACgHAgciAABLhCwIAQEAAAECASwOAgEmAgIECywMHQMiAABLvgw4AwIEIwIABAAATEgiAABL0CwNAQMmAgUECwYoBQIBJgIHBAMAOAUHBiwIAQQAEAEGASYDBAQBACgEAgYsDgUGACgGAgYsDgUGJgIHBAMAOAQHBgAoAwIHLQQAB4ADLQQABoAELQQABYAFJAAAUAUAKAQCBiwNBgUmAgcEAgA4BgcDNg0AAwAFJSYCBgQLDDgDBgcjAgAHAABMXyQAAECYACgFAgYAOAYDBywNBwQsDQEGJgIIBAsMOAMICSMCAAkAAEyIJAAAQJgtBAAGgAMnAIAEBAAMJAAAUEstCIAFAAcAKAcCCAA4CAMJLA4ECSwOBwEAOAMgBCwMBAMiAABLviwNBgcsDQUIADgIAwoOOAgKCyMCAAsAAEzfJAAAQg8mAgsECQw4AwsMIwIADAAATPYkAABAmAAoCQILADgLAwwsDQwIJgIMBAsMOAoMDSMCAA0AAE0bJAAAQJgtBAAHgAMnAIAEBAAMJAAAUEstCIAFAAsAKAsCDAA4DAoNLA4IDSwOCwYAOAMgBywMBwMiAABK6AI4CwMMDjgDCw0jAgANAABNaiQAAFI2AjgMIA0OOCAMDiMCAA4AAE2BJAAAUjYsDQUMJgIPBAUMOA0PECMCABAAAE2cJAAAQJgAKAoCDwA4Dw0QLA0QDhwMDg0ALA0HDgQ4DQ4PADgMDw0sDg0FBDgOCAwsDgwHADgDIAwsDAwDIgAASj4sDQUGHAwDBwAAOB4HCC4MAAgAByYCCQQJDDgDCQojAgAKAABOAyQAAECYLQQABoADJwCABAQACiQAAFBLLQiABQAIACgIAgkAOAkDCiwOBwosDggFADgDIAYsDAYDIgAASIYsDR8EHAwiBQAAOAMFBi4MAAYABSYCBwQDDDgiBwgjAgAIAABOZiQAAECYLQQABIADJwCABAQABCQAAFBLLQiABQAGACgGAgcAOAciCCwOBQgsDgYfADgiIAQsDAQiIgAARJEkAAAiHCwNAQMsDQIEJgIGBAMMOAQGByMCAAcAAE7CJAAAQJgAKAMCBgA4BgQHLA0HBSwIAQYmAgcEAgAQAQcBJgMGBAEAKAYCBywMBwgsDgUIJgIFBAEAOAQFBw44BAcIIwIACAAATwwkAABCDywOAwEsDgcCLAwGASUkAAAiHCYCBgQHLAgABywMAQgsDAIJABAABgAkAABOniwEAAAsDAgFJgIBAAQKOAMBAiYCAQQAACgFAgcAOAcBCCwNCAYjAgACAABPryIAAE9rJgIBABEKOAMBAiMCAAIAAE+mIgAAT4ImAgEAggo4AwECIwIAAgAAT50mAgUEADsJAQUsDAYEIgAAT7gsDAYEIgAAT7gsDAYEIgAAT7gsDAQBJSkBAAEF7FAZWNnuATg7AQECJSkBAAEFY5jT8h3nWWQ7AQECJSkBAAEFgw2jMUCxgSA7AQECJSkBAAEFhUwVuY+esCk7AQECJQEAgAOABYAHLQCAA4AILQCABIAJCwCACIAHgAojAIAKAABQSi0BgAiABi0CgAaACQEAgAgAAoAIAQCACQACgAkiAABQGSUtAYADgAYLAIAGAAKAByMAgAcAAFBmIgAAUHEtAIADgAUiAABQ2C0AAAGABQEAAAGABAABAQCAA4AEgAktAIADgAotAIAFgAsLAIAKgAmADCMAgAwAAFDELQGACoAILQKACIALAQCACgACgAoBAIALAAKACyIAAFCTJwGABQQAAQMAgAYAAoAGIgAAUNglJAAAIhwmAgYEASYCBwQALAwHBSIAAFDxDSgABYBDAAcjAgAHAABRYSIAAFEGLA0BBSwNAgYsDQMHLA0ECCYCCQQELAgBCiYCCwQFABABCwEmAwoEAQAoBgILJgIMBAQAKAoCDT4PAAsADSwNCgYAKAYCBiwOBgosDgUBLA4KAiwOBwMsDggEJSwNAwcMOAUHCAA4BQYHIwIACAAAUXwiAABSLSwNAQgsDQIJLA0DCiwNBAsmAg0EBAw4BQ0OIwIADgAAUaMkAABAmAAoCQINADgNBQ4sDQ4MJgIOBAMMOAUODyMCAA8AAFHIJAAAQJgAKAgCDgA4DgUPLA0PDQA4DA0OJgINBAQMOAUNDyMCAA8AAFHyJAAAQJgtBAAJgAMnAIAEBAAFJAAAUEstCIAFAAwAKAwCDQA4DQUPLA4ODywOCAEsDgwCLA4KAywOCwQiAABSLSwMBwUiAABQ8SkBAAEFKIaSsEfc/UM7AQECJSkBAAEFHwotJ9yCh6I7AQECJSkBAAEFvh4//z6k9vo7AQECJSQAACIcLA0BAywNAgQmAgYEAgw4BAYHIwIABwAAUpAkAABAmAAoAwIGADgGBAcsDQcFLAgBBiYCBwQCABABBwEmAwYEAQAoBgIHLAwHCCwOBQgmAgUEAQA4BAUHDjgEBwgjAgAIAABS2iQAAEIPLA4DASwOBwIsDAYBJSQAACIcLAgBBCYCBQQDABABBQEmAwQEAQAoBAIFLAwFBiwOAQYAKAYCBiwOAgYqAgABAAAAAAAAAAACAAAAAAAAAAAmAggECSwIAAksDAEKABAACAAkAAA39ywEAAAsDAoCLAwLBSwMDAYsDA0HLA0CAQAoAQIBLA4BAiwIAQEAAAECASwOAgEsDQUCACgCAgIsDgIFLAgBAgAAAQIBLA4FAiwIAQUAAAECASwOBgUsCAEGAAABAgEsDgcGJgIHBAAmAggEASYCCQQCLAwHAyIAAFO7DDgDCQcjAgAHAABT/SIAAFPNJgIEBAcsCAAHLAwBCCwMAgksDAUKLAwGCwAQAAQAJAAAOJ4sBAAALAwIAywMAwElIwIABwAAVAoiAABUXyYCCgQCDDgDCgsjAgALAABUISQAAECYACgEAgoAOAoDCywNCwcmAgoECywIAAssDAEMLAwCDSwMBQ4sDAYPLAwHEAAQAAoAJAAAQLwsBAAAIgAAVF8AOAMIBywMBwMiAABTuykBAAEFAtxuJ4B2Ep07AQECJSQAACIcLA0BAywNAgQmAgYEBAw4BAYHIwIABwAAVKMkAABAmAAoAwIGADgGBAcsDQcFLAgBBiYCBwQCABABBwEmAwYEAQAoBgIHLAwHCCwOBQgmAgUEAQA4BAUHDjgEBwgjAgAIAABU7SQAAEIPLA4DASwOBwIsDAYBJSkBAAEFTLRGnBDK9+87AQECJSkBAAEFkjkKWT1h7YQ7AQECJS0AGMoYyg==",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "set_admin",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8778930052620580050": {
            "error_kind": "string",
            "string": "caller is not an admin"
          }
        },
        "parameters": [
          {
            "name": "new_admin",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JgACBAEnAAABBIBFJgAABAMmAgIEASYCAwQAHxgAAwACgEQtCIBEAAEkAAAARSQAAABGJwIAAQSARSYCAgQAOg0AAQACJSQAAACYHgIAAgAeAgADADI4AAIAAwAEJgICAQEjAgAEAAAAbyQAAADBJgICAAMuDAACAAMeAgAEAQo4AwQFIwIABQAAAJEkAAAA0y8MAAEAAiUnAIAEBHgADQAAAIAEgAMjAIADAAAAwCkBAAEF96Hzr6Wt1Mo7AQECJSkBAAEFvh4//z6k9vo7AQECJSkBAAEFedUGXr5zdNI7AQECJS0AGMoYyg==",
      "debug_symbols": "5VXbisIwEP2XPPchc+kk8VeWZalapVCq1LqwiP++ibRp1WJAdF/2pWTKmZ4zM6eZk1qXy+P2q2o2u4NafJxUvVsVXbVrfHQ6Z2rZVnVdbb+mr5UOD5Nf8Id90YTw0BVtpxYggpkqm3U4GvRf2FR1qRbij/dgrfMBrDGPYAAzg2Zm06OZc4lom8+ALcVPW0KYgj8zZfULtNsI9uL/UPsr+s4Q+y6pvkMuES0B8Ui7IzeAHRPfaHf0Uu2gr7UHBvtuBt+xt1MAzFGgZtdnoRaToABykULGQYDMzdiQpR5tWPPjGRuI1jd47c85HZporFXkxhJe3P+pFXG+VkOxVgePa2XBwTr+6FI3icF4k1hzJ8ckW+94KickET6RxPqZpNmbDoGGBiDkOuEMwjgQYpdyhiUZhm1zm3CGRNMZcTrlDOBxXYClq1GcffRdtFWxrMt+726OzWqyhruffXmzkfftblWuj20ZdvO4liF0Gm1GdPm5fEAmI+c5PM8v",
      "brillig_names": [
        "set_admin"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "H4sIAAAAAAAA/7WTyw7CIBBFqcUo0sTEx39MU0y7dOHafyCtLHVRN+766dZkJkyI0QVwEzJMgMNcHoXwKjBKESGCHDEqjAs2Xs7tjDnEqVbBvin5HRijvvhLWH+jkFnk4QPxM50/rJBzmTyfe6F913PTrF8J/z5y+af7y+l//8OzRq9bzCvh/8P4uvfXx/M2ij/SbJGc0ptoOwAqvkT+EvmhJBvn8w+Yb4Svj6KMqNO1tnaNdfZkh8H0dhfwP+KH/QbzqHp4zgQAAA==",
      "debug_symbols": "bY/dCoMwDIXfJddeNHUO9FVkSNUohdJKrYNRfPelm0j3cxPOCV8OORFG6re503ZyKzRtBOMGFbSz7OJeQO+1MXru8jWINLB88euibLJrUD5AU10KIDtCc5V8PWlDb/kDokAhD5a1rE8cq/I/X+PJSxQf/G1ne1deq97Q8fq02SFrEh4LfZVavBto3Dylelkzni1WhRQcy9FP",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "_finalize_transfer_to_private_unsafe",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "10536464181608181124": {
            "error_kind": "string",
            "string": "transfer not prepared"
          },
          "11859452850824495745": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 60
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17028138060491915576": {
            "error_kind": "string",
            "string": "Function _finalize_transfer_to_private_unsafe can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5527120278801020911": {
            "error_kind": "string",
            "string": "invalid NFT owner"
          }
        },
        "parameters": [
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hiding_point_slot",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_finalize_transfer_to_private_unsafe"
      ]
    },
    {
      "name": "private_get_name",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2111772463301017956": {
            "error_kind": "string",
            "string": "Function private_get_name can only be called statically"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "NFTNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "token_id",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "NFT"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "private_nfts",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "nft_exists",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_owners",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "from",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "to",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "token_id",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::NFTTransfer"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::private_get_name_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::private_get_name_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::get_admin_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::get_admin_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::transfer_in_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::transfer_in_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::transfer_to_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::transfer_to_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::transfer_in_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::transfer_in_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::private_get_symbol_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::private_get_symbol_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "name",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  },
                  {
                    "name": "symbol",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "inner_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::cancel_authwit_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::cancel_authwit_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::_finish_transfer_to_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::_finish_transfer_to_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hiding_point_slot",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::_finalize_transfer_to_private_unsafe_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::_finalize_transfer_to_private_unsafe_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::owner_of_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::owner_of_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "new_admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::set_admin_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::set_admin_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::mint_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::mint_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::private_mint_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::private_mint_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::public_get_symbol_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::public_get_symbol_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::public_get_name_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::public_get_name_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::prepare_private_balance_increase_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::prepare_private_balance_increase_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "slot",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "point",
                    "type": {
                      "fields": [
                        {
                          "name": "x",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "y",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "is_infinite",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                    }
                  },
                  {
                    "name": "setup_log",
                    "type": {
                      "kind": "array",
                      "length": 9,
                      "type": {
                        "kind": "field"
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::_store_payload_in_transient_storage_unsafe_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::_store_payload_in_transient_storage_unsafe_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::transfer_to_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::transfer_to_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hiding_point_slot",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::finalize_transfer_to_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::finalize_transfer_to_private_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "107": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        /// Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "109": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::embedded_curve_ops::multi_scalar_mul;\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "110": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::{\n    embedded_curve_ops::fixed_base_scalar_mul, field::bn254::decompose,\n    hash::from_field_unsafe as fr_to_fq_unsafe,\n};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "111": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    /// Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "117": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "126": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/note/discovery/mod.nr",
      "source": "use std::static_assert;\n\nuse crate::{\n    context::unconstrained_context::UnconstrainedContext, note::note_header::NoteHeader,\n    oracle::note_discovery::deliver_note, utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\n    hash::compute_note_hash_nonce,\n};\n\n// We reserve two fields in the note log that are not part of the note content: one for the storage slot, and one for\n// the note type id.\nglobal NOTE_LOG_RESERVED_FIELDS: u32 = 2;\npub global MAX_NOTE_SERIALIZED_LEN: u32 = PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_LOG_RESERVED_FIELDS;\n\npub struct NoteHashesAndNullifier {\n    pub note_hash: Field,\n    pub unique_note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Processes a log given its plaintext by trying to find notes encoded in it. This process involves the discovery of\n/// the nonce of any such notes, which requires knowledge of the transaction hash in which the notes would've been\n/// created, along with the list of unique note hashes in said transaction.\n///\n/// Additionally, this requires a `compute_note_hash_and_nullifier` lambda that is able to compute these values for any\n/// note in the contract given their contents. A typical implementation of such a function would look like this:\n///\n/// ```\n/// |packed_note_content, note_header, note_type_id| {\n///     let hashes = if note_type_id == MyNoteType::get_note_type_id() {\n///         assert(packed_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///         dep::aztec::note::utils::compute_note_hash_and_optionally_a_nullifier(\n///             MyNoteType::unpack_content,\n///             note_header,\n///             true,\n///             packed_note_content.storage(),\n///         )\n///     } else {\n///         panic(f\"Unknown note type id {note_type_id}\")\n///     };\n///\n///     Option::some(dep::aztec::oracle::management::NoteHashesAndNullifier {\n///         note_hash: hashes[0],\n///         unique_note_hash: hashes[1],\n///         inner_nullifier: hashes[3],\n///     })\n/// }\n/// ```\npub unconstrained fn do_process_log<Env>(\n    context: UnconstrainedContext,\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: fn[Env](BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>, NoteHeader, Field) -> Option<NoteHashesAndNullifier>,\n) {\n    let (storage_slot, note_type_id, packed_note_content) =\n        destructure_log_plaintext(log_plaintext);\n\n    // We need to find the note's nonce, which is the one that results in one of the unique note hashes from tx_hash\n    for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            let header = NoteHeader::new(context.this_address(), candidate_nonce, storage_slot);\n\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes =\n                compute_note_hash_and_nullifier(packed_note_content, header, note_type_id).unwrap();\n\n            if hashes.unique_note_hash == expected_unique_note_hash {\n                // TODO(#10726): push these into a vec to deliver all at once instead of having one oracle call per note\n\n                assert(\n                    deliver_note(\n                        context.this_address(), // TODO(#10727): allow other contracts to deliver notes\n                        storage_slot,\n                        candidate_nonce,\n                        packed_note_content,\n                        hashes.note_hash,\n                        hashes.inner_nullifier,\n                        tx_hash,\n                        recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n}\n\nunconstrained fn destructure_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>) {\n    assert(log_plaintext.len() >= NOTE_LOG_RESERVED_FIELDS);\n\n    // If NOTE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\n    // `storage_slot` and `note_type_id` must be updated as well.\n    static_assert(\n        NOTE_LOG_RESERVED_FIELDS == 2,\n        \"unepxected value for NOTE_LOG_RESERVED_FIELDS\",\n    );\n    let storage_slot = log_plaintext.get(0);\n    let note_type_id = log_plaintext.get(1);\n\n    let packed_note_content = array::subbvec(log_plaintext, NOTE_LOG_RESERVED_FIELDS);\n\n    (storage_slot, note_type_id, packed_note_content)\n}\n\nfn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..MaxLen {\n        if i < vec.len() {\n            f(vec.get_unchecked(i), i);\n        }\n    }\n}\n"
    },
    "127": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_header::NoteHeader,\n    note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_nullify_internal, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let packed_note_content = Note::pack_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        packed_note_content,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"
    },
    "129": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "131": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\nuse dep::protocol_types::constants::{\n    GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note_content: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note_content[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(context: PrivateContext, storage_slot: Field, note: Note)\nwhere\n    Note: NoteInterface<N>,\n{\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_content<let N: u32>(\n    packed_note_content: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note_content, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (Note, Field)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    /// Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    /// is check that the metadata is correct, and that the note exists.\n    let note = unsafe { get_note_internal(storage_slot) };\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    /// Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::array::collapse(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> =\n        BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.pack_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_content(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note\nwhere\n    Note: NoteInterface<N>,\n{\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length,\n    )[0]\n        .expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteInterface<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteInterface<N>,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "136": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/note/note_viewer_options.nr",
      "source": "use crate::note::constants::MAX_NOTES_PER_PAGE;\nuse crate::note::note_getter_options::{NoteStatus, PropertySelector, Select, Sort};\nuse crate::note::note_interface::NoteInterface;\nuse dep::protocol_types::traits::ToField;\nuse std::option::Option;\n\n// docs:start:NoteViewerOptions\npub struct NoteViewerOptions<Note, let N: u32> {\n    pub selects: BoundedVec<Option<Select>, N>,\n    pub sorts: BoundedVec<Option<Sort>, N>,\n    pub limit: u32,\n    pub offset: u32,\n    pub status: u8,\n}\n// docs:end:NoteViewerOptions\n\nimpl<Note, let N: u32> NoteViewerOptions<Note, N> {\n    pub fn new() -> NoteViewerOptions<Note, N>\n    where\n        Note: NoteInterface<N>,\n    {\n        NoteViewerOptions {\n            selects: BoundedVec::new(),\n            sorts: BoundedVec::new(),\n            limit: MAX_NOTES_PER_PAGE as u32,\n            offset: 0,\n            status: NoteStatus.ACTIVE,\n        }\n    }\n\n    // This method adds a `Select` criterion to the options.\n    // It takes a field_index indicating which field to select,\n    // a value representing the specific value to match in that field, and\n    // a comparator (For possible values of comparators, please see the Comparator enum from note_getter_options)\n    pub fn select<T>(\n        &mut self,\n        property_selector: PropertySelector,\n        comparator: u8,\n        value: T,\n    ) -> Self\n    where\n        T: ToField,\n    {\n        self.selects.push(Option::some(Select::new(property_selector, comparator, value.to_field())));\n        *self\n    }\n\n    pub fn sort(&mut self, property_selector: PropertySelector, order: u8) -> Self {\n        self.sorts.push(Option::some(Sort::new(property_selector, order)));\n        *self\n    }\n\n    pub fn set_limit(&mut self, limit: u32) -> Self {\n        assert(limit <= MAX_NOTES_PER_PAGE as u32);\n        // By requesting that the limit is a constant, we guarantee that it will be possible to loop over it, reducing\n        // gate counts when a limit has been set.\n        if !dep::std::runtime::is_unconstrained() {\n            assert_constant(limit);\n        }\n        self.limit = limit;\n        *self\n    }\n\n    pub fn set_offset(&mut self, offset: u32) -> Self {\n        self.offset = offset;\n        *self\n    }\n\n    // This method sets the status value, which determines whether to retrieve active or nullified notes.\n    pub fn set_status(&mut self, status: u8) -> Self {\n        self.status = status;\n        *self\n    }\n}\n"
    },
    "137": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n    utils::array,\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    compute_unique_note_hash,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let header = note.get_header();\n    let nonce = header.nonce;\n    let counter = header.note_hash_counter;\n\n    // If same tx note, read request always uses the normal note hash\n    if counter != 0 {\n        note_hash\n    } else {\n        // If the note comes from a different tx, we need to compute the note hash that reached the tree\n        compute_unique_note_hash(\n            nonce,\n            compute_siloed_note_hash(header.contract_address, note_hash),\n        )\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if (header.note_hash_counter != 0) & (header.nonce != 0) {\n        // Non-revertible note, nullified by a revertible nullifier, we need to nullify the note hash that will reach the tree\n        let siloed_note_hash =\n            compute_siloed_note_hash(header.contract_address, note_hash_for_read_request);\n\n        compute_unique_note_hash(header.nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    unpack_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    packed_note_content: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = unpack_content(array::subarray(packed_note_content, 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, note_hash);\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"
    },
    "139": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "140": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "141": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "142": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field]) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\n}\n\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\n    let _ = store_in_execution_cache_oracle(values);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "143": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    /// Safety: The to_address function combines all values in the instance object to produce an address,\n    /// so by checking that we get the expected address we validate the entire struct.\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "147": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\n    }\n}\n"
    },
    "148": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "149": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "152": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr",
      "source": "use crate::note::discovery::MAX_NOTE_SERIALIZED_LEN;\nuse dep::protocol_types::address::AztecAddress;\n\n/// Informs PXE of a note's existence so that it can later retrieved by the `getNotes` oracle. The note will be scoped\n/// to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The note's `content` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value is\n/// typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are the\n/// inner hashes, i.e. the raw hashes returned by `NoteInterface::compute_note_hash` and\n/// `NullifiableNote::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree at\n/// `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was sucessfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    content: BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        content,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    content: BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n"
    },
    "153": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note_content,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        packed_note_content,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note_content: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    let _ = notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    sync_notes_oracle_wrapper();\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let note_content = array::subarray(fields, read_offset + 2);\n\n            let mut note = Note::unpack_content(note_content);\n            note.set_header(NoteHeader { contract_address, nonce, storage_slot, note_hash_counter });\n\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_indexed_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\n/// for later querying via the `get_notes` oracle.\npub fn sync_notes() {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        sync_notes_oracle_wrapper();\n    }\n}\n\nunconstrained fn sync_notes_oracle_wrapper() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n"
    },
    "155": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "159": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "164": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest, constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::Packable,\n};\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateSet<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // TODO: This function is still around because of a stale blacklist token. It should most likely be nuked. If you\n    // need this functionality use partial notes instead.\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "166": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    state_vars::storage::Storage,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    pub fn read(self) -> T {\n        let header = self.context.get_block_header();\n        let mut fields = [0; T_PACKED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] = header.public_storage_historical_read(\n                self.storage_slot + i as Field,\n                (*self.context).this_address(),\n            );\n        }\n        T::unpack(fields)\n    }\n}\n"
    },
    "167": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicMutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicMutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "17": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "18": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    /// Safety: borrow is enforced to be boolean due to its type.\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        /*@safety: borrow is enforced to be boolean due to its type.\n            if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n            if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n        */\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        /// Safety: decomposition is properly checked below\n        unsafe {\n            /*@safety: decomposition is properly checked below*/\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            /// Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unsafe in unconstrained\n        unsafe {\n            //@safety: unsafe in unconstrained\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        /// Safety: Take a hint of the comparison and verify it\n        unsafe {\n            //@safety: Take a hint of the comparison and verify it\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "185": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr",
      "source": "/// Collapses an array of `Option`s with sparse `Some` values into a `BoundedVec`, essentially unwrapping the `Option`s\n/// and removing the `None` values.\n///\n/// For example, given:\n///   `input: [some(3), none(), some(1)]`\n/// this returns\n///   `collapsed: [3, 1]`\npub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collapsed BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n\n    /// Safety: The hints are verified by the `verify_collapse_hints` function.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\nfn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n\nmod test {\n    use super::{collapse, verify_collapse_hints};\n\n    #[test]\n    unconstrained fn collapse_empty_array() {\n        let original: [Option<Field>; 2] = [Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn collapse_non_sparse_array() {\n        let original = [Option::some(7), Option::some(3), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_sparse_array() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_front_padding() {\n        let original =\n            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_back_padding() {\n        let original =\n            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn verify_collapse_hints_good_hints() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec length\")]\n    unconstrained fn verify_collapse_hints_wrong_length() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Collapse hint vec length mismatch\")]\n    unconstrained fn verify_collapse_hints_hint_length_mismatch() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Out of bounds index hint\")]\n    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn verify_collapse_hints_hint_to_none() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 0]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec content\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_content() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 42]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec order\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_order() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([3, 7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Dirty collapsed vec storage\")]\n    unconstrained fn verify_collapse_hints_dirty_storage() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n\n        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);\n        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.\n        collapsed.set_unchecked(2, 1);\n\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n}\n"
    },
    "187": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "188": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    vec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(vec.storage(), offset), vec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "189": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/utils/bytes.nr",
      "source": "use crate::oracle::random::random;\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole bytes.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted into a Field. If the last chunk\n/// is less than 31 bytes long, then only the relevant bytes are considered.\n/// For example, [1, 10, 3] is encoded as [1 * 256^2 + 10 * 256 + 3]\n/// Note: ceil(N / 31) = (N + 30) / 31\npub fn be_bytes_31_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; (N + 30) / 31] {\n    let mut fields = [0; (N + 30) / 31];\n\n    // There are N / 31 whole fields that can be populated.\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    // Note: if 31 divides N, then this loop does not execute.\n    // ceil(N/31) - floor(N/31) = 1, unless 31 divides N, in which case it's 0.\n    for _ in 0..((N + 30) / 31) - (N / 31) {\n        let mut final_field = 0;\n        let final_field_idx = fields.len() - 1;\n        let final_offset = final_field_idx * 31;\n        // N - ((N / 31) * 31) = N - floor(N/31) * 31 = the number of bytes to go in the final field.\n        for j in 0..N - ((N / 31) * 31) {\n            // Shift the existing value left by 8 bits and add the new byte\n            final_field = final_field * 256 + bytes[final_offset + j] as Field;\n        }\n\n        fields[final_field_idx] = final_field;\n    }\n\n    fields\n}\n\npub fn le_bytes_31_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; (N + 30) / 31] {\n    let mut fields = [0; (N + 30) / 31];\n\n    // There are N / 31 whole fields that can be populated.\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            let k = 31 - j - 1; // iterate in reverse.\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + k] as Field;\n        }\n        fields[i] = field;\n    }\n\n    // Note: if 31 divides N, then this loop does not execute.\n    // ceil(N/31) - floor(N/31) = 1, unless 31 divides N, in which case it's 0.\n    for _ in 0..((N + 30) / 31) - (N / 31) {\n        let mut final_field = 0;\n        let final_field_idx = fields.len() - 1;\n        let final_offset = final_field_idx * 31;\n        // N - ((N / 31) * 31) = N - floor(N/31) * 31 = the number of bytes to go in the final field.\n        for j in 0..N - ((N / 31) * 31) {\n            let k = (N - ((N / 31) * 31)) - j - 1; // iterate in reverse.\n            // Shift the existing value left by 8 bits and add the new byte\n            final_field = final_field * 256 + bytes[final_offset + k] as Field;\n        }\n        fields[final_field_idx] = final_field;\n    }\n\n    fields\n}\n\n/// Converts an input array of fields into a single array of bytes.\n/// Each input field must contain only 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte\n/// chunks are concatenated back together in the order of the original fields.\n///\n/// It appears that the original author of this function wants to give the caller some control\n/// over the number of bytes that are returned: the final field can be mapped to fewer than 31 bytes,\n/// based on the caller's choice of M.\n/// Given the input is N fields, and each field (except the last) is mapped to 31 bytes,\n/// we definitely need M > (N - 1) * 31 to cover those first (N - 1) fields. Hence the static assertion.\n/// TODO: this is the same as the \"le\" version of this function, save for the `field.to_be_bytes()` calls. I tried passing the conversion function in as a parameter, to reduce code duplication, but couldn't get it to work.\npub fn fields_to_be_bytes_31<let N: u32, let M: u32>(fields: [Field; N]) -> [u8; M] {\n    let mut bytes = [0; M];\n\n    std::static_assert(M > (N - 1) * 31, \"Not enough output bytes specified\");\n    // We make this assertion to keep the logic simpler:\n    std::static_assert(N * 31 >= M, \"Too many output bytes specified.\");\n\n    for i in 0..N - 1 {\n        let field = fields[i];\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes[i * 31 + j] = field_as_bytes[j];\n        }\n    }\n\n    let final_field = fields[N - 1];\n    final_field.assert_max_bit_size::<8 * (M - ((N - 1) * 31))>();\n\n    let final_field_as_bytes: [u8; M - ((N - 1) * 31)] = final_field.to_be_bytes();\n\n    let start_index = (N - 1) * 31;\n    for j in 0..M - ((N - 1) * 31) {\n        bytes[start_index + j] = final_field_as_bytes[j];\n    }\n\n    bytes\n}\n\n/// Converts an input array of fields into a single array of bytes.\n/// Each input field must contain only 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 little-endian bytes, and the resulting 31-byte\n/// chunks are concatenated back together in the order of the original fields. You'll\n/// end up with quite a strange ordering of bytes if you use this particular function.\npub fn fields_to_le_bytes_31<let N: u32, let M: u32>(fields: [Field; N]) -> [u8; M] {\n    let mut bytes = [0; M];\n\n    std::static_assert(M > (N - 1) * 31, \"Not enough output bytes specified\");\n    // We make this assertion to keep the logic simpler:\n    std::static_assert(N * 31 >= M, \"Too many output bytes specified.\");\n\n    for i in 0..N - 1 {\n        let field = fields[i];\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_le_bytes();\n\n        for j in 0..31 {\n            bytes[i * 31 + j] = field_as_bytes[j];\n        }\n    }\n\n    let final_field = fields[N - 1];\n    final_field.assert_max_bit_size::<8 * (M - ((N - 1) * 31))>();\n\n    let final_field_as_bytes: [u8; M - ((N - 1) * 31)] = final_field.to_le_bytes();\n\n    let start_index = (N - 1) * 31;\n    for j in 0..M - ((N - 1) * 31) {\n        bytes[start_index + j] = final_field_as_bytes[j];\n    }\n\n    bytes\n}\n\n/// Converts an input array of fields into a single array of bytes.\n/// Each field is converted to a 32-byte big-endian array.\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end,\n/// every 32 bytes. Be careful that such a gap doesn't leak information!\npub fn fields_to_be_bytes_32<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field = fields[i];\n        let field_as_bytes: [u8; 32] = field.to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\nunconstrained fn byte_to_bits(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n\n/// Returns as many random bits as specified through N.\nunconstrained fn get_random_bits<let N: u32>() -> [u1; N] {\n    // Note: (N + 7) / 8 = ceil(N / 8)\n    let bytes = get_random_bytes::<(N + 7) / 8>();\n    let mut bits: [u1; N] = [0; N];\n    for i in 0..bytes.len() - 1 {\n        let mut byte = bytes[i];\n        for j in 0..8 {\n            let bit_idx = i * 8 + j;\n            bits[bit_idx] = (byte & 1) as u1;\n            byte >>= 1;\n        }\n    }\n\n    // N - ((N / 8) * 8) = N - floor(N/8) * 8 = the number of bits remaining.\n    let byte_idx = bytes.len() - 1;\n    let mut byte = bytes[byte_idx];\n    for j in 0..N - ((N / 8) * 8) {\n        let bit_idx = (byte_idx) * 8 + j;\n        bits[bit_idx] = (byte & 1) as u1;\n        byte >>= 1;\n    }\n\n    bits\n}\n\n/// Returns random bits, in chunks, according to the provided numeric generics.\nunconstrained fn get_chunks_of_random_bits<let NUM_CHUNKS: u32, let NUM_BITS: u32>() -> [[u1; NUM_BITS]; NUM_CHUNKS] {\n    let random_bits = get_random_bits::<NUM_CHUNKS * NUM_BITS>();\n    let mut chunks: [[u1; NUM_BITS]; NUM_CHUNKS] = [[0; NUM_BITS]; NUM_CHUNKS];\n    for i in 0..NUM_CHUNKS {\n        let mut chunk: [u1; NUM_BITS] = [0; NUM_BITS];\n        for j in 0..NUM_BITS {\n            chunk[j] = random_bits[i * NUM_BITS + j];\n        }\n        chunks[i] = chunk;\n    }\n    chunks\n}\n\n/**\n * Helper fn for be/le_bytes_to_padded_fields() fns.\n */\nfn pad_31_byte_fields_with_random_bits<let N: u32>(input: [Field; N]) -> [Field; N] {\n    /// Safety: we can't constrain whether or not the returned bits are actually random;\n    /// we can only rely on it being in the caller's best interest.\n    let chunks_of_random_bits = unsafe { get_chunks_of_random_bits::<((N + 30) / 31), 6>() };\n    let mut fields = input;\n    // We push the random bits to the \"big end\" of each field\n    let TWO_POW_248 = 0x100000000000000000000000000000000000000000000000000000000000000;\n    for i in 0..fields.len() {\n        let mut shift = TWO_POW_248;\n        for j in 0..5 {\n            fields[i] += shift * chunks_of_random_bits[i][j] as Field;\n            shift *= 2;\n        }\n\n        // This might overflow the field modulus, so we need to be careful.\n        // By this point, shift = 2 ^ 253, so will populate the 254th bit (counting from 1)\n        let field_with_254th_bit = fields[i] + shift * chunks_of_random_bits[i][6 - 1] as Field;\n\n        // Expensive comparison (one for each field), but it's important -- if we want to hide that we were\n        // working with bytes -- that we include the 254th random bit when it fits.\n        fields[i] = if (fields[i].lt(field_with_254th_bit)) {\n            field_with_254th_bit\n        } else {\n            fields[i]\n        };\n    }\n    fields\n}\n\n/**\n * The above functions be_bytes_31_to_fields and le_bytes_31_to_fields have a privacy-leakage problem:\n * they result in fields which are all 248-bits instead of 254-bits.\n * That means if the above functions are used to convert a ciphertext from bytes to\n * fields, it leaks (with very high probability) to all observers of the log that the\n * ciphertext was created with a \"bit twiddly\" encryption scheme like AES.\n * This reduces privacy sets for all apps.\n *\n * This function seeks to \"pad\" those remaining 6 bits with randomness, so that all\n * encrypted logs look even more similar (full fields of 254-bits of random-looking\n * information). Of course, this adds some extra constraints, unfortunately.\n */\npub fn le_bytes_to_padded_fields<let N: u32>(input: [u8; N]) -> [Field; (N + 30) / 31] {\n    let mut fields = le_bytes_31_to_fields(input);\n    pad_31_byte_fields_with_random_bits(fields)\n}\n\npub fn be_bytes_to_padded_fields<let N: u32>(input: [u8; N]) -> [Field; (N + 30) / 31] {\n    let mut fields = be_bytes_31_to_fields(input);\n    pad_31_byte_fields_with_random_bits(fields)\n}\n\nmod test {\n    use crate::utils::bytes::{\n        be_bytes_31_to_fields, fields_to_be_bytes_31, fields_to_le_bytes_31, le_bytes_31_to_fields,\n    };\n\n    // BE BYTES\n\n    #[test]\n    fn test_be_bytes_31_to_1_field() {\n        let input = [\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31,\n        ];\n        let output = be_bytes_31_to_fields(input);\n\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\n    }\n\n    #[test]\n    fn test_1_field_to_be_bytes_31() {\n        let input = [0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f];\n        let output: [u8; 31] = fields_to_be_bytes_31(input);\n\n        assert_eq(\n            output,\n            [\n                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n                24, 25, 26, 27, 28, 29, 30, 31,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_be_bytes_31() {\n        let input = [1, 2, 3];\n        let output: [u8; 93] = fields_to_be_bytes_31(input);\n\n        // Each field should occupy 31 bytes with the non-zero value being placed in the last one.\n        assert_eq(\n            output,\n            [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 3,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_fewer_be_bytes() {\n        let input = [1, 2, 3];\n        let output: [u8; 63] = fields_to_be_bytes_31(input);\n        println(f\"output: {output}\");\n\n        // First 2 fields should occupy 31 bytes with the non-zero value being placed in the last one while the last\n        // field should occupy 1 byte. There is not information destruction here because the last field fits into\n        // 1 byte.\n        assert_eq(\n            output,\n            [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 2, 3,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_be_bytes_31_to_2_fields() {\n        let input = [\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,\n            47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        ];\n        let output = be_bytes_31_to_fields(input);\n\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\n        assert_eq(output[1], 0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b);\n    }\n\n    #[test]\n    fn test_2_fields_to_be_bytes_31() {\n        let input = [\n            0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f,\n            0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b,\n        ];\n        let output: [u8; 62] = fields_to_be_bytes_31(input);\n\n        assert_eq(\n            output,\n            [\n                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n                24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,\n                43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_large_random_be_bytes_31_input_to_fields_and_back(input: [u8; 128]) {\n        let output = be_bytes_31_to_fields(input);\n        let input_back: [u8; 128] = fields_to_be_bytes_31(output);\n\n        assert_eq(input, input_back);\n    }\n\n    // I need to get an array of random values lower than 2^248 on input and since there is no u248 type and modulo\n    // operation is not supported on a Field (to do field % 2^248), I will take multiple smaller values and combine\n    // them to get a value lower than 2^248.\n    #[test]\n    fn test_large_random_input_to_be_bytes_31_and_back(\n        input1: [u64; 5],\n        input2: [u64; 5],\n        input3: [u64; 5],\n        input4: [u32; 5],\n        input5: [u16; 5],\n        input6: [u8; 5],\n    ) {\n        let mut input = [0; 5];\n        for i in 0..5 {\n            input[i] = (input1[i] as Field * 2.pow_32(184))\n                + (input2[i] as Field * 2.pow_32(120))\n                + (input3[i] as Field * 2.pow_32(56))\n                + (input4[i] as Field * 2.pow_32(24))\n                + (input5[i] as Field * 2.pow_32(8))\n                + input6[i] as Field;\n        }\n\n        let output: [u8; 155] = fields_to_be_bytes_31(input);\n        let input_back = be_bytes_31_to_fields(output);\n\n        assert_eq(input, input_back);\n    }\n\n    #[test(should_fail_with = \"call to assert_max_bit_size\")]\n    fn test_too_few_destination_be_bytes() {\n        // We should get an error here because first field gets converted to 31 bytes and the second field needs\n        // at least 2 bytes but we provide it with 1.\n        let input = [1, 256];\n        let _ignored_result: [u8; 32] = fields_to_be_bytes_31(input);\n    }\n\n    #[test(should_fail_with = \"call to assert_max_bit_size\")]\n    fn test_fields_to_be_bytes_31_value_too_large() {\n        let input = [2.pow_32(248)]; // this number is 1 bit larger than 31 bytes.\n        let _ignored_result: [u8; 31] = fields_to_be_bytes_31(input);\n    }\n\n    #[test]\n    fn test_fields_to_be_bytes_31_max_value() {\n        let input = [2.pow_32(248) - 1];\n        let result: [u8; 31] = fields_to_be_bytes_31(input);\n\n        // We check that all the bytes were set to max value (255)\n        for i in 0..31 {\n            assert_eq(result[i], 255);\n        }\n    }\n\n    // LE BYTES\n\n    #[test]\n    fn test_le_bytes_31_to_1_field() {\n        let input = [\n            31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10,\n            9, 8, 7, 6, 5, 4, 3, 2, 1,\n        ];\n        let output = le_bytes_31_to_fields(input);\n\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\n    }\n\n    #[test]\n    fn test_1_field_to_le_bytes_31() {\n        let input = [0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f];\n        let output: [u8; 31] = fields_to_le_bytes_31(input);\n\n        assert_eq(\n            output,\n            [\n                31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11,\n                10, 9, 8, 7, 6, 5, 4, 3, 2, 1,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_le_bytes_31() {\n        let input = [1, 2, 3];\n        let output: [u8; 93] = fields_to_le_bytes_31(input);\n\n        // Each field should occupy 31 bytes with the non-zero value being placed in the last one.\n        assert_eq(\n            output,\n            [\n                1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_fewer_le_bytes() {\n        let input = [1, 2, 3];\n        let output: [u8; 63] = fields_to_le_bytes_31(input);\n\n        // First 2 fields should occupy 31 bytes with the non-zero value being placed in the last one while the last\n        // field should occupy 1 byte. There is not information destruction here because the last field fits into\n        // 1 byte.\n        assert_eq(\n            output,\n            [\n                1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 3,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_le_bytes_31_to_2_fields() {\n        let input = [\n            59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38,\n            37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16,\n            15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1,\n        ];\n        let output = le_bytes_31_to_fields(input);\n\n        assert_eq(output[0], 0x1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b);\n        assert_eq(output[1], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c);\n    }\n\n    #[test]\n    fn test_2_fields_to_le_bytes_31() {\n        let input = [\n            0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f,\n            0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b,\n        ];\n        let output: [u8; 62] = fields_to_le_bytes_31(input);\n\n        assert_eq(\n            output,\n            [\n                31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11,\n                10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47,\n                46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 0, 0, 0,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_large_random_le_bytes_input_to_fields_and_back(input: [u8; 128]) {\n        let output = le_bytes_31_to_fields(input);\n        let input_back: [u8; 128] = fields_to_le_bytes_31(output);\n\n        assert_eq(input, input_back);\n    }\n\n    // I need to get an array of random values lower than 2^248 on input and since there is no u248 type and modulo\n    // operation is not supported on a Field (to do field % 2^248), I will take multiple smaller values and combine\n    // them to get a value lower than 2^248.\n    #[test]\n    fn test_large_random_input_to_le_bytes_and_back(\n        input1: [u64; 5],\n        input2: [u64; 5],\n        input3: [u64; 5],\n        input4: [u32; 5],\n        input5: [u16; 5],\n        input6: [u8; 5],\n    ) {\n        let mut input = [0; 5];\n        for i in 0..5 {\n            input[i] = (input1[i] as Field * 2.pow_32(184))\n                + (input2[i] as Field * 2.pow_32(120))\n                + (input3[i] as Field * 2.pow_32(56))\n                + (input4[i] as Field * 2.pow_32(24))\n                + (input5[i] as Field * 2.pow_32(8))\n                + input6[i] as Field;\n        }\n\n        let output: [u8; 155] = fields_to_le_bytes_31(input);\n        let input_back = le_bytes_31_to_fields(output);\n\n        assert_eq(input, input_back);\n    }\n\n    #[test(should_fail_with = \"call to assert_max_bit_size\")]\n    fn test_too_few_destination_le_bytes() {\n        // We should get an error here because first field gets converted to 31 bytes and the second field needs\n        // at least 2 bytes but we provide it with 1.\n        let input = [1, 256];\n        let _ignored_result: [u8; 32] = fields_to_le_bytes_31(input);\n    }\n\n    #[test(should_fail_with = \"call to assert_max_bit_size\")]\n    fn test_fields_to_le_bytes_31_value_too_large() {\n        let input = [2.pow_32(248)];\n        let _ignored_result: [u8; 31] = fields_to_le_bytes_31(input);\n    }\n\n    #[test]\n    fn test_fields_to_le_bytes_31_max_value() {\n        let input = [2.pow_32(248) - 1];\n        let result: [u8; 31] = fields_to_le_bytes_31(input);\n\n        // We check that all the bytes were set to max value (255)\n        for i in 0..31 {\n            assert_eq(result[i], 255);\n        }\n    }\n}\n"
    },
    "19": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    // #[test]\n    // fn test_to_le_radix_brillig_1() {\n    //     // this test should only fail in constrained mode\n    //     if runtime::is_unconstrained() {\n    //         let field = 1;\n    //         let out: [u8; 8] = field.to_le_radix(1);\n    //         crate::println(out);\n    //         let expected = [0; 8];\n    //         assert(out == expected, \"unexpected result\");\n    //     }\n    // }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    // #[test]\n    // fn test_to_le_radix_brillig_512() {\n    //     // this test should only fail in constrained mode\n    //     if runtime::is_unconstrained() {\n    //         let field = 1;\n    //         let out: [u8; 8] = field.to_le_radix(512);\n    //         let mut expected = [0; 8];\n    //         expected[0] = 1;\n    //         assert(out == expected, \"unexpected result\");\n    //     }\n    // }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "190": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/utils/comparison.nr",
      "source": "struct ComparatorEnum {\n    pub EQ: u8,\n    pub NEQ: u8,\n    pub LT: u8,\n    pub LTE: u8,\n    pub GT: u8,\n    pub GTE: u8,\n}\n\npub global Comparator: ComparatorEnum =\n    ComparatorEnum { EQ: 1, NEQ: 2, LT: 3, LTE: 4, GT: 5, GTE: 6 };\n\npub fn compare(lhs: Field, operation: u8, rhs: Field) -> bool {\n    // Values are computed ahead of time because circuits evaluate all branches\n    let is_equal = lhs == rhs;\n    let is_lt = lhs.lt(rhs);\n\n    if (operation == Comparator.EQ) {\n        is_equal\n    } else if (operation == Comparator.NEQ) {\n        !is_equal\n    } else if (operation == Comparator.LT) {\n        is_lt\n    } else if (operation == Comparator.LTE) {\n        is_lt | is_equal\n    } else if (operation == Comparator.GT) {\n        !is_lt & !is_equal\n    } else if (operation == Comparator.GTE) {\n        !is_lt\n    } else {\n        panic(f\"Invalid operation\")\n    }\n}\n\nmod test {\n    use super::Comparator;\n    use super::compare;\n\n    #[test]\n    unconstrained fn test_compare() {\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.LT, rhs), \"Expected lhs to be less than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.LTE, rhs), \"Expected lhs to be less than or equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.GT, rhs), \"Expected lhs to be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(!compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to not be not equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.LT, rhs), \"Expected lhs to not be less than rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            !compare(lhs, Comparator.LTE, rhs),\n            \"Expected lhs to not be less than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.GT, rhs), \"Expected lhs to not be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n    }\n}\n"
    },
    "193": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::point_to_bytes;\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n"
    },
    "21": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    /// Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "212": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "247": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "254": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        function_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            function_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "26": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "269": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "27": {
      "path": "std/hash/sha256.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        /// Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        /// Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    /// Safety: the msg_len is checked below in verify_msg_len\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n\n        /// Safety: testing context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        /// Safety: test context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        /// Safety: testing context\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n"
    },
    "270": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "271": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::{constants::TWO_POW_64, utils::{arrays::array_concat, field::field_from_bytes}};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_contract_class_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_contract_class_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; N * 32];\n    for offset in 0..N {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "272": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "281": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "287": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "288": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "297": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        /// Safety: `sorted` array is checked to be:\n        /// a. a permutation of `input`'s elements\n        /// b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n"
    },
    "300": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "313": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "317": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::{Packable, ToField};\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for U128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self.to_field()]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "318": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 2;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        // We use little-endian ordering to match the order in which U128 defines its limbs.\n        // This is necessary because of how Noir handles serialization:\n        // - When calling a contract function from TypeScript, the serialization in encoder.ts gets used and then Noir\n        //   deserializes using its intrinsic serialization logic (based on the limb order in the struct).\n        // - When calling a contract function from another function, the `serialize` method is invoked on the type\n        //   first.\n        // For this reason if we didn't use the ordering of U128 limbs here and in encoder.ts we would get an arguments\n        // hash mismatch.\n        [self.lo, self.hi]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_u64s_le(fields[0] as u64, fields[1] as u64)\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "334": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    /// Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    /// of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "335": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "337": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "342": {
      "path": "/Users/hka/nargo/github.com/noir-lang/ec/v0.1.2/src/lib.nr",
      "source": "// Elliptic curve implementation\n// Overview\n// ========\n// The following three elliptic curve representations are admissible:\npub mod tecurve; // Twisted Edwards curves\npub mod swcurve; // Elliptic curves in Short Weierstrass form\npub mod montcurve; // Montgomery curves\npub mod consts; // Commonly used curve presets\n//\n// Note that Twisted Edwards and Montgomery curves are (birationally) equivalent, so that\n// they may be freely converted between one another, whereas Short Weierstrass curves are\n// more general. Diagramatically:\n//\n// tecurve == montcurve `subset` swcurve\n//\n// Each module is further divided into two submodules, 'affine' and 'curvegroup', depending\n// on the preferred coordinate representation. Affine coordinates are none other than the usual\n// two-dimensional Cartesian coordinates used in the definitions of these curves, whereas\n// 'CurveGroup' coordinates (terminology borrowed from Arkworks, whose conventions we try\n// to follow) are special coordinate systems with respect to which the group operations may be\n// implemented more efficiently, usually by means of an appropriate choice of projective coordinates.\n//\n// In each of these submodules, there is a Point struct and a Curve struct, the former\n// representing a point in the coordinate system and the latter a curve configuration.\n//\n// Points\n// ======\n// Points may be instantiated using the associated function `new`, which takes coordinates\n// as its arguments. For instance,\n//\n// `let p = swcurve::Point::new(1,1);`\n//\n// The additive identity may be constructed by a call to the associated function `zero` of no\n// arguments:\n//\n// `let zero = swcurve::Point::zero();`\n//\n// Points may be tested for equality by calling the method `eq`:\n//\n// `let pred = p.eq(zero);`\n//\n// There is also the method `is_zero` to explicitly check whether a point is the additive identity:\n//\n// `constrain pred == p.is_zero();`\n//\n// Points may be negated by calling the `negate` method and converted to CurveGroup (or affine)\n// coordinates by calling the `into_group` (resp. `into_affine`) method on them. Finally,\n// Points may be freely mapped between their respective Twisted Edwards and Montgomery\n// representations by calling the `into_montcurve` or `into_tecurve` methods. For mappings\n// between Twisted Edwards/Montgomery curves and Short Weierstrass curves, see the Curve section\n// below, as the underlying mappings are those of curves rather than ambient spaces.\n// As a rule, Points in affine (or CurveGroup) coordinates are mapped to Points in affine\n// (resp. CurveGroup) coordinates.\n//\n// Curves\n// ======\n// A curve configuration (Curve) is completely determined by the Field coefficients of its defining\n// equation (a and b in the case of swcurve, a and d in the case of tecurve, and j and k in\n// the case of montcurve) together with a generator (`gen`) in the corresponding coordinate system.\n// For example, the Baby Jubjub curve configuration as defined in ERC-2494 may be instantiated as a Twisted\n// Edwards curve in affine coordinates as follows:\n//\n// `let bjj_affine = tecurve::Curve::new(168700, 168696, tecurve::Point::new(995203441582195749578291179787384436505546430278305826713579947235728471134,5472060717959818805561601436314318772137091100104008585924551046643952123905));`\n//\n// The `contains` method may be used to check whether a Point lies on a given curve:\n//\n// `constrain bjj_affine.contains(tecurve::Point::zero());`\n//\n// The elliptic curve group's addition operation is exposed as the `add` method, e.g.\n//\n// `let p = bjj_affine.add(bjj_affine.gen, bjj_affine.gen);`\n//\n// subtraction as the `subtract` method, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.subtract(bjj_affine.gen, bjj_affine.gen));`\n//\n// scalar multiplication as the `mul` method, where the scalar is assumed to be a Field* element, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.mul(2, tecurve::Point::zero());`\n//\n// There is a scalar multiplication method (`bit_mul`) provided where the scalar input is expected to be\n// an array of bits (little-endian convention), as well as a multi-scalar multiplication method** (`msm`)\n// which takes an array of Field elements and an array of elliptic curve points as arguments, both assumed\n// to be of the same length.\n//\n// Curve configurations may be converted between different coordinate representations by calling the `into_group`\n// and `into_affine` methods on them, e.g.\n//\n// `let bjj_curvegroup = bjj_affine.into_group();`\n//\n// Curve configurations may also be converted between different curve representations by calling the `into_swcurve`,\n// `into_montcurve` and `into_tecurve` methods subject to the relation between the curve representations mentioned\n// above. Note that it is possible to map Points from a Twisted Edwards/Montgomery curve to the corresponding\n// Short Weierstrass representation and back, and the methods to do so are exposed as `map_into_swcurve` and\n// `map_from_swcurve`, which each take one argument, the point to be mapped.\n//\n// Curve maps\n// ==========\n// There are a few different ways of mapping Field elements to elliptic curves. Here we provide the simplified\n// Shallue-van de Woestijne-Ulas and Elligator 2 methods, the former being applicable to all curve types\n// provided above subject to the constraint that the coefficients of the corresponding Short Weierstrass curve satisfies\n// a*b != 0 and the latter being applicable to Montgomery and Twisted Edwards curves subject to the constraint that\n// the coefficients of the corresponding Montgomery curve satisfy j*k != 0 and (j^2 - 4)/k^2 is non-square.\n//\n// The simplified Shallue-van de Woestijne-Ulas method is exposed as the method `swu_map` on the Curve configuration and\n// depends on two parameters, a Field element z != -1 for which g(x) - z is irreducible over Field and g(b/(z*a)) is\n// square, where g(x) = x^3 + a*x + b is the right-hand side of the defining equation of the corresponding Short\n// Weierstrass curve, and a Field element u to be mapped onto the curve. For example, in the case of bjj_affine above,\n// it may be determined using the scripts provided at <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve> that z = 5.\n//\n// The Elligator 2 method is exposed as the method `elligator2_map` on the Curve configurations of Montgomery and\n// Twisted Edwards curves. Like the simplified SWU method above, it depends on a certain non-square element of Field,\n// but this element need not satisfy any further conditions, so it is included as the (Field-dependent) constant\n//`ZETA` below. Thus, the `elligator2_map` method depends only on one parameter, the Field element to be mapped onto\n// the curve.\n//\n// For details on all of the above in the context of hashing to elliptic curves, see <https://datatracker.ietf.org/doc/id/draft-irtf-cfrg-hash-to-curve-06.html>.\n//\n//\n// *TODO: Replace Field with Bigint.\n// **TODO: Support arrays of structs to make this work.\n// Field-dependent constant ZETA = a non-square element of Field\n// Required for Elligator 2 map\n// TODO: Replace with built-in constant.\nglobal ZETA: Field = 5;\n// Field-dependent constants for Tonelli-Shanks algorithm (see sqrt function below)\n// TODO: Possibly make this built-in.\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n// Higher-order version of scalar multiplication\n// TODO: Make this work so that the submodules' bit_mul may be defined in terms of it.\n//fn bit_mul<T,N>(add: fn(T,T) -> T, e: T, bits: [u1; N], p: T) -> T {\n//    let mut out = e;\n//    let n = bits.len();\n//\n//    for i in 0..n {\n//        out = add(\n//            add(out, out),\n//            if(bits[n - i - 1] == 0) {e} else {p});\n//    }\n//\n//    out\n//}\n// TODO: Make this built-in.\npub fn safe_inverse(x: Field) -> Field {\n    if x == 0 {\n        0\n    } else {\n        1 / x\n    }\n}\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\npub fn is_square(x: Field) -> bool {\n    let v = pow(x, 0 - 1 / 2);\n\n    v * (v - 1) == 0\n}\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\nmod tests {\n    use crate::montcurve::affine::Point as MGaffine;\n    use crate::montcurve::curvegroup::Point as MG;\n    use crate::swcurve::affine::Point as SWGaffine;\n    use crate::swcurve::curvegroup::Point as SWG;\n    use crate::tecurve::affine::Curve as AffineCurve;\n    use crate::tecurve::affine::Point as Gaffine;\n    use crate::tecurve::curvegroup::Point as G;\n\n    #[test]\n    fn smoke_test() {\n        // Tests may be checked against https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/tree/main/poc\n        // Define Baby Jubjub (ERC-2494) parameters in affine representation\n        let bjj_affine = AffineCurve::new(\n            168700,\n            168696,\n            Gaffine::new(\n                995203441582195749578291179787384436505546430278305826713579947235728471134,\n                5472060717959818805561601436314318772137091100104008585924551046643952123905,\n            ),\n        );\n        // Test addition\n        let p1_affine = Gaffine::new(\n            17777552123799933955779906779655732241715742912184938656739573121738514868268,\n            2626589144620713026669568689430873010625803728049924121243784502389097019475,\n        );\n        let p2_affine = Gaffine::new(\n            16540640123574156134436876038791482806971768689494387082833631921987005038935,\n            20819045374670962167435360035096875258406992893633759881276124905556507972311,\n        );\n\n        let p3_affine = bjj_affine.add(p1_affine, p2_affine);\n        assert(p3_affine.eq(Gaffine::new(\n            7916061937171219682591368294088513039687205273691143098332585753343424131937,\n            14035240266687799601661095864649209771790948434046947201833777492504781204499,\n        )));\n        // Test scalar multiplication\n        let p4_affine = bjj_affine.mul(2, p1_affine);\n        assert(p4_affine.eq(Gaffine::new(\n            6890855772600357754907169075114257697580319025794532037257385534741338397365,\n            4338620300185947561074059802482547481416142213883829469920100239455078257889,\n        )));\n        assert(p4_affine.eq(bjj_affine.bit_mul([0, 1], p1_affine)));\n        // Test subtraction\n        let p5_affine = bjj_affine.subtract(p3_affine, p3_affine);\n        assert(p5_affine.eq(Gaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_affine.contains(bjj_affine.gen)\n                & bjj_affine.contains(p1_affine)\n                & bjj_affine.contains(p2_affine)\n                & bjj_affine.contains(p3_affine)\n                & bjj_affine.contains(p4_affine)\n                & bjj_affine.contains(p5_affine),\n        );\n        // Test CurveGroup equivalents\n        let bjj = bjj_affine.into_group(); // Baby Jubjub\n        let p1 = p1_affine.into_group();\n        let p2 = p2_affine.into_group();\n        let p3 = p3_affine.into_group();\n        let p4 = p4_affine.into_group();\n        let p5 = p5_affine.into_group();\n        // Test addition\n        assert(p3.eq(bjj.add(p1, p2)));\n        // Test scalar multiplication\n        assert(p4.eq(bjj.mul(2, p1)));\n        assert(p4.eq(bjj.bit_mul([0, 1], p1)));\n        // Test subtraction\n        assert(G::zero().eq(bjj.subtract(p3, p3)));\n        assert(p5.eq(G::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj.contains(bjj.gen)\n                & bjj.contains(p1)\n                & bjj.contains(p2)\n                & bjj.contains(p3)\n                & bjj.contains(p4)\n                & bjj.contains(p5),\n        );\n        // Test SWCurve equivalents of the above\n        // First the affine representation\n        let bjj_swcurve_affine = bjj_affine.into_swcurve();\n\n        let p1_swcurve_affine = bjj_affine.map_into_swcurve(p1_affine);\n        let p2_swcurve_affine = bjj_affine.map_into_swcurve(p2_affine);\n        let p3_swcurve_affine = bjj_affine.map_into_swcurve(p3_affine);\n        let p4_swcurve_affine = bjj_affine.map_into_swcurve(p4_affine);\n        let p5_swcurve_affine = bjj_affine.map_into_swcurve(p5_affine);\n        // Addition\n        assert(p3_swcurve_affine.eq(bjj_swcurve_affine.add(p1_swcurve_affine, p2_swcurve_affine)));\n        // Doubling\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.mul(2, p1_swcurve_affine)));\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.bit_mul([0, 1], p1_swcurve_affine)));\n        // Subtraction\n        assert(SWGaffine::zero().eq(bjj_swcurve_affine.subtract(\n            p3_swcurve_affine,\n            p3_swcurve_affine,\n        )));\n        assert(p5_swcurve_affine.eq(SWGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve_affine.contains(bjj_swcurve_affine.gen)\n                & bjj_swcurve_affine.contains(p1_swcurve_affine)\n                & bjj_swcurve_affine.contains(p2_swcurve_affine)\n                & bjj_swcurve_affine.contains(p3_swcurve_affine)\n                & bjj_swcurve_affine.contains(p4_swcurve_affine)\n                & bjj_swcurve_affine.contains(p5_swcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_swcurve = bjj.into_swcurve();\n\n        let p1_swcurve = bjj.map_into_swcurve(p1);\n        let p2_swcurve = bjj.map_into_swcurve(p2);\n        let p3_swcurve = bjj.map_into_swcurve(p3);\n        let p4_swcurve = bjj.map_into_swcurve(p4);\n        let p5_swcurve = bjj.map_into_swcurve(p5);\n        // Addition\n        assert(p3_swcurve.eq(bjj_swcurve.add(p1_swcurve, p2_swcurve)));\n        // Doubling\n        assert(p4_swcurve.eq(bjj_swcurve.mul(2, p1_swcurve)));\n        assert(p4_swcurve.eq(bjj_swcurve.bit_mul([0, 1], p1_swcurve)));\n        // Subtraction\n        assert(SWG::zero().eq(bjj_swcurve.subtract(p3_swcurve, p3_swcurve)));\n        assert(p5_swcurve.eq(SWG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve.contains(bjj_swcurve.gen)\n                & bjj_swcurve.contains(p1_swcurve)\n                & bjj_swcurve.contains(p2_swcurve)\n                & bjj_swcurve.contains(p3_swcurve)\n                & bjj_swcurve.contains(p4_swcurve)\n                & bjj_swcurve.contains(p5_swcurve),\n        );\n        // Test MontCurve conversions\n        // First the affine representation\n        let bjj_montcurve_affine = bjj_affine.into_montcurve();\n\n        let p1_montcurve_affine = p1_affine.into_montcurve();\n        let p2_montcurve_affine = p2_affine.into_montcurve();\n        let p3_montcurve_affine = p3_affine.into_montcurve();\n        let p4_montcurve_affine = p4_affine.into_montcurve();\n        let p5_montcurve_affine = p5_affine.into_montcurve();\n        // Addition\n        assert(p3_montcurve_affine.eq(bjj_montcurve_affine.add(\n            p1_montcurve_affine,\n            p2_montcurve_affine,\n        )));\n        // Doubling\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.mul(2, p1_montcurve_affine)));\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.bit_mul([0, 1], p1_montcurve_affine)));\n        // Subtraction\n        assert(MGaffine::zero().eq(bjj_montcurve_affine.subtract(\n            p3_montcurve_affine,\n            p3_montcurve_affine,\n        )));\n        assert(p5_montcurve_affine.eq(MGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve_affine.contains(bjj_montcurve_affine.gen)\n                & bjj_montcurve_affine.contains(p1_montcurve_affine)\n                & bjj_montcurve_affine.contains(p2_montcurve_affine)\n                & bjj_montcurve_affine.contains(p3_montcurve_affine)\n                & bjj_montcurve_affine.contains(p4_montcurve_affine)\n                & bjj_montcurve_affine.contains(p5_montcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_montcurve = bjj.into_montcurve();\n\n        let p1_montcurve = p1_montcurve_affine.into_group();\n        let p2_montcurve = p2_montcurve_affine.into_group();\n        let p3_montcurve = p3_montcurve_affine.into_group();\n        let p4_montcurve = p4_montcurve_affine.into_group();\n        let p5_montcurve = p5_montcurve_affine.into_group();\n        // Addition\n        assert(p3_montcurve.eq(bjj_montcurve.add(p1_montcurve, p2_montcurve)));\n        // Doubling\n        assert(p4_montcurve.eq(bjj_montcurve.mul(2, p1_montcurve)));\n        assert(p4_montcurve.eq(bjj_montcurve.bit_mul([0, 1], p1_montcurve)));\n        // Subtraction\n        assert(MG::zero().eq(bjj_montcurve.subtract(p3_montcurve, p3_montcurve)));\n        assert(p5_montcurve.eq(MG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve.contains(bjj_montcurve.gen)\n                & bjj_montcurve.contains(p1_montcurve)\n                & bjj_montcurve.contains(p2_montcurve)\n                & bjj_montcurve.contains(p3_montcurve)\n                & bjj_montcurve.contains(p4_montcurve)\n                & bjj_montcurve.contains(p5_montcurve),\n        );\n        // Elligator 2 map-to-curve\n        let ell2_pt_map = bjj_affine.elligator2_map(27);\n\n        assert(ell2_pt_map.eq(MGaffine::new(\n            7972459279704486422145701269802978968072470631857513331988813812334797879121,\n            8142420778878030219043334189293412482212146646099536952861607542822144507872,\n        )\n            .into_tecurve()));\n        // SWU map-to-curve\n        let swu_pt_map = bjj_affine.swu_map(5, 27);\n\n        assert(swu_pt_map.eq(bjj_affine.map_from_swcurve(SWGaffine::new(\n            2162719247815120009132293839392097468339661471129795280520343931405114293888,\n            5341392251743377373758788728206293080122949448990104760111875914082289313973,\n        ))));\n    }\n\n}\n"
    },
    "350": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/compressed-string/src/field_compressed_string.nr",
      "source": "use dep::aztec::protocol_types::{\n    traits::{Deserialize, Packable, Serialize},\n    utils::field::field_from_bytes,\n};\nuse std::meta::derive;\n\n// A Fixedsize Compressed String.\n// Essentially a special version of Compressed String for practical use.\n#[derive(Deserialize, Packable, Serialize)]\npub struct FieldCompressedString {\n    value: Field,\n}\n\nimpl FieldCompressedString {\n    pub fn is_eq(self, other: FieldCompressedString) -> bool {\n        self.value == other.value\n    }\n\n    pub fn from_field(input_field: Field) -> Self {\n        Self { value: input_field }\n    }\n\n    pub fn from_string(input_string: str<31>) -> Self {\n        Self { value: field_from_bytes(input_string.as_bytes(), true) }\n    }\n\n    pub fn to_bytes(self) -> [u8; 31] {\n        self.value.to_be_bytes()\n    }\n}\n"
    },
    "51": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "52": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "6": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "62": {
      "path": "/Users/hka/tezac/src/contracts/src/main.nr",
      "source": "mod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract NFT {\n    use crate::types::nft_note::NFTNote;\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit, assert_current_call_valid_authwit_public,\n        compute_authwit_nullifier,\n    };\n    use dep::aztec::{\n        encrypted_logs::log_assembly_strategies::default_aes128::note::encode_and_encrypt_note,\n        macros::{\n            events::event,\n            functions::{initializer, internal, private, public, view},\n            storage::storage,\n        },\n        note::constants::MAX_NOTES_PER_PAGE,\n        oracle::random::random,\n        prelude::{\n            AztecAddress, Map, NoteGetterOptions, NoteViewerOptions, PrivateContext, PrivateSet,\n            PublicContext, PublicImmutable, PublicMutable,\n        },\n        protocol_types::{point::Point, traits::Serialize},\n        utils::comparison::Comparator,\n    };\n    use dep::compressed_string::FieldCompressedString;\n    use std::meta::derive;\n\n    #[derive(Serialize)]\n    #[event]\n    pub struct NFTTransfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        token_id: Field,\n    }\n\n    #[storage]\n    struct Storage<Context> {\n        symbol: PublicImmutable<FieldCompressedString, Context>,\n        name: PublicImmutable<FieldCompressedString, Context>,\n        admin: PublicMutable<AztecAddress, Context>,\n        private_nfts: Map<AztecAddress, PrivateSet<NFTNote, Context>, Context>,\n        nft_exists: Map<Field, PublicMutable<bool, Context>, Context>,\n        public_owners: Map<Field, PublicMutable<AztecAddress, Context>, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n    }\n\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not an admin\");\n        storage.admin.write(new_admin);\n    }\n\n    #[public]\n    fn mint(to: AztecAddress, token_id: Field) {\n        assert(token_id != 0, \"zero token ID not supported\");\n        assert(storage.nft_exists.at(token_id).read() == false, \"token already exists\");\n\n        storage.nft_exists.at(token_id).write(true);\n\n        storage.public_owners.at(token_id).write(to);\n    }\n\n    #[private]\n    fn private_mint(to: AztecAddress, token_id: Field) {\n        assert(token_id != 0, \"zero token ID not supported\");\n\n        let nfts = storage.private_nfts;\n        let notes = nfts.at(to).pop_notes(NoteGetterOptions::new()\n            .select(NFTNote::properties().token_id, Comparator.EQ, token_id)\n            .set_limit(1));\n        assert(notes.len() == 0, \"token already exists\");\n\n        nfts.at(to).insert(&mut NFTNote::new(token_id, to)).emit(\n            encode_and_encrypt_note(&mut context, to, to)\n        );\n    }\n\n    #[public]\n    #[view]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[public]\n    #[view]\n    fn get_admin() -> Field {\n        storage.admin.read().to_field()\n    }\n\n    #[public]\n    fn transfer_in_public(from: AztecAddress, to: AztecAddress, token_id: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let public_owners_storage = storage.public_owners.at(token_id);\n        assert(public_owners_storage.read().eq(from), \"invalid owner\");\n\n        public_owners_storage.write(to);\n    }\n\n    #[private]\n    fn transfer_to_private(to: AztecAddress, token_id: Field) {\n        let from = context.msg_sender();\n\n        let nft = NFT::at(context.this_address());\n\n        // We prepare the private balance increase.\n        let hiding_point_slot = _prepare_private_balance_increase(to, &mut context, storage);\n\n        // At last we finalize the transfer. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that he can transfer only his own NFTs.\n        nft._finalize_transfer_to_private_unsafe(from, token_id, hiding_point_slot).enqueue(\n            &mut context,\n        );\n    }\n\n    /// Prepares an increase of private balance of `to` (partial note). The increase needs to be finalized by calling\n    /// `finalize_transfer_to_private. Returns a hiding point slot.\n    // docs:start:prepare_private_balance_increase\n    #[private]\n    fn prepare_private_balance_increase(to: AztecAddress) -> Field {\n        _prepare_private_balance_increase(to, &mut context, storage)\n    }\n    \n    /// This function exists separately from `prepare_private_balance_increase` solely as an optimization as it allows\n    /// us to have it inlined in the `transfer_to_private` function which results in one less kernel iteration.\n    ///\n    #[contract_library_method]\n    fn _prepare_private_balance_increase(\n        to: AztecAddress,\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n    ) -> Field {\n        let to_note_slot = storage.private_nfts.at(to).storage_slot;\n\n        // We create a setup payload with unpopulated/zero token id for 'to'\n\n        /// Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        /// so a malicious sender could use non-random values to make the note less private. But they already know\n        /// the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        /// information. We can therefore assume that the sender will cooperate in the random value generation.\n        let note_randomness = unsafe { random() };\n        let note_setup_payload = NFTNote::setup_payload().new(to, note_randomness, to_note_slot);\n\n        let setup_log = note_setup_payload.encrypt_log(context, to, context.msg_sender());\n\n        // Using the x-coordinate as a hiding point slot is safe against someone else interfering with it because\n        // we have a guarantee that the public functions of the transaction are executed right after the private ones\n        // and for this reason the protocol guarantees that nobody can front-run us in consuming the hiding point.\n        // This guarantee would break if `finalize_transfer_to_private` was not called in the same transaction. This\n        // however is not the flow we are currently concerned with. To support the multi-transaction flow we could\n        // introduce a `from` function argument, hash the x-coordinate with it and then repeat the hashing in\n        // `finalize_transfer_to_private`.\n\n        // We can also be sure that the `hiding_point_slot` will not overwrite any other value in the storage because\n        // in our state variables we derive slots using a different hash function from multi scalar multiplication\n        // (MSM).\n        let hiding_point_slot = note_setup_payload.hiding_point.x;\n\n        // We don't need to perform a check that the value overwritten by `_store_point_in_transient_storage_unsafe`\n        // is zero because the slot is the x-coordinate of the hiding point and hence we could only overwrite\n        // the value in the slot with the same value. This makes usage of the `unsafe` method safe.\n        NFT::at(context.this_address())\n            ._store_payload_in_transient_storage_unsafe(\n                hiding_point_slot,\n                note_setup_payload.hiding_point,\n                setup_log,\n            )\n            .enqueue(context);\n\n        hiding_point_slot\n    }\n\n    // TODO(#9375): Having to define the note log length here is very unfortunate as it's basically impossible for\n    // users to derive manually. This will however go away once we have a real transient storage since we will not need\n    // the public call and instead we would do something like `context.transient_storage_write(slot, payload)` and that\n    // will allow us to use generics and hence user will not need to define it explicitly. We cannot use generics here\n    // as it is an entrypoint function.\n    // docs:start:store_payload_in_transient_storage_unsafe\n    #[public]\n    #[internal]\n    fn _store_payload_in_transient_storage_unsafe(\n        slot: Field,\n        point: Point,\n        setup_log: [Field; 9],\n    ) {\n        context.storage_write(slot, point);\n        context.storage_write(slot + aztec::protocol_types::point::POINT_LENGTH as Field, setup_log);\n    }\n\n    /// Finalizes a transfer of NFT with `token_id` from public balance of `from` to a private balance of `to`.\n    /// The transfer must be prepared by calling `prepare_private_balance_increase` first and the resulting\n    /// `hiding_point_slot` must be passed as an argument to this function.\n    // docs:start:finalize_transfer_to_private\n    #[public]\n    fn finalize_transfer_to_private(token_id: Field, hiding_point_slot: Field) {\n        let from = context.msg_sender();\n        _finalize_transfer_to_private(from, token_id, hiding_point_slot, &mut context, storage);\n    }\n\n    #[public]\n    #[internal]\n    fn _finalize_transfer_to_private_unsafe(\n        from: AztecAddress,\n        token_id: Field,\n        hiding_point_slot: Field,\n    ) {\n        _finalize_transfer_to_private(from, token_id, hiding_point_slot, &mut context, storage);\n    }\n\n    #[contract_library_method]\n    fn _finalize_transfer_to_private(\n        from: AztecAddress,\n        token_id: Field,\n        hiding_point_slot: Field,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        let public_owners_storage = storage.public_owners.at(token_id);\n        assert(public_owners_storage.read().eq(from), \"invalid NFT owner\");\n\n        // Set the public NFT owner to zero\n        public_owners_storage.write(AztecAddress::zero());\n\n        // Finalize the partial note with the `token_id`\n        let finalization_payload =\n            NFTNote::finalization_payload().new(context, hiding_point_slot, token_id);\n\n        // At last we emit the note hash and the final log\n        finalization_payload.emit();\n    }\n\n    //\n    // Cancel a private authentication witness.\n    // @param inner_hash The inner hash of the authwit to cancel.\n    //\n    #[private]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n\n    #[private]\n    fn transfer_in_private(from: AztecAddress, to: AztecAddress, token_id: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let nfts = storage.private_nfts;\n\n        let notes = nfts.at(from).pop_notes(NoteGetterOptions::new()\n            .select(NFTNote::properties().token_id, Comparator.EQ, token_id)\n            .set_limit(1));\n        assert(notes.len() == 1, \"NFT not found when transferring\");\n\n        let mut new_note = NFTNote::new(token_id, to);\n\n        nfts.at(to).insert(&mut new_note).emit(encode_and_encrypt_note(&mut context, to, from));\n    }\n\n    #[private]\n    fn transfer_to_public(from: AztecAddress, to: AztecAddress, token_id: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let notes = storage.private_nfts.at(from).pop_notes(NoteGetterOptions::new()\n            .select(NFTNote::properties().token_id, Comparator.EQ, token_id)\n            .set_limit(1));\n        assert(notes.len() == 1, \"NFT not found when transferring to public\");\n\n        NFT::at(context.this_address())._finish_transfer_to_public(to, token_id).enqueue(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _finish_transfer_to_public(to: AztecAddress, token_id: Field) {\n        storage.public_owners.at(token_id).write(to);\n    }\n\n    #[public]\n    #[view]\n    // Returns zero address when the token does not have a public owner. Reverts if the token does not exist.\n    fn owner_of(token_id: Field) -> AztecAddress {\n        assert(storage.nft_exists.at(token_id).read(), \"token does not exist\");\n        storage.public_owners.at(token_id).read()\n    }\n\n    /// Returns an array of token IDs owned by `owner` in private and a flag indicating whether a page limit was\n    /// reached. Starts getting the notes from page with index `page_index`. Zero values in the array are placeholder\n    /// values for non-existing notes.\n    // docs:start:get_private_nfts\n    unconstrained fn get_private_nfts(\n        owner: AztecAddress,\n        page_index: u32,\n    ) -> pub ([Field; MAX_NOTES_PER_PAGE], bool) {\n        let offset = page_index * MAX_NOTES_PER_PAGE;\n        let mut options = NoteViewerOptions::new();\n        let notes = storage.private_nfts.at(owner).view_notes(options.set_offset(offset));\n\n        let mut owned_nft_ids = [0; MAX_NOTES_PER_PAGE];\n        for i in 0..options.limit {\n            if i < notes.len() {\n                owned_nft_ids[i] = notes.get_unchecked(i).token_id;\n            }\n        }\n\n        let page_limit_reached = notes.len() == options.limit;\n        (owned_nft_ids, page_limit_reached)\n    }\n}\n"
    },
    "66": {
      "path": "/Users/hka/tezac/src/contracts/src/types/nft_note.nr",
      "source": "use dep::aztec::{\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::partial_note,\n    note::utils::compute_note_hash_for_nullify,\n    oracle::random::random,\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator, traits::Packable,\n    },\n};\n\n// docs:start:nft_note\n#[partial_note(quote {token_id})]\npub struct NFTNote {\n    // ID of the token\n    token_id: Field,\n    // The owner of the note\n    owner: AztecAddress,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:nft_note\n\nimpl NullifiableNote for NFTNote {\n    // docs:start:compute_nullifier\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:compute_nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl NFTNote {\n    pub fn new(token_id: Field, owner: AztecAddress) -> Self {\n        /// Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        /// so a malicious sender could use non-random values to make the note less private. But they already know\n        /// the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        /// information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        NFTNote { token_id, owner, randomness, header: NoteHeader::empty() }\n    }\n}\n\nimpl Eq for NFTNote {\n    fn eq(self, other: Self) -> bool {\n        (self.token_id == other.token_id)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}"
    },
    "69": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/authwit/src/auth.nr",
      "source": "use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\nuse dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\nglobal IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "7": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "77": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub gas_opts: GasOpts,\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"
    },
    "84": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        execution_cache::store(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            /// Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            /// for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        /// Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        /// execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        /// the number of side effects that took place), along with the hash of the return values. We validate these\n        /// by requesting a private kernel iteration in which the return values are constrained to hash\n        /// to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        /// WARNING: This is insecure and should be temporary!\n        /// The oracle hashes the arguments and returns a new args_hash.\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        /// We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        /// b) this is only temporary.\n        let args_hash = unsafe {\n            enqueue_public_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.set_public_teardown_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        /// WARNING: This is insecure and should be temporary!\n        /// The oracle hashes the arguments and returns a new args_hash.\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        /// We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        /// b) this is only temporary.\n        let args_hash = unsafe {\n            set_public_teardown_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "85": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, Packable, Serialize};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            /// Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            /// Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "86": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        /// Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "87": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "89": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypt/aes128.nr",
      "source": "use std::hash::{from_field_unsafe as fr_to_fq_unsafe, sha256};\n\nuse dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::utils::point::point_to_bytes;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n"
    },
    "93": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/log_assembly_strategies/default_aes128/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    encrypted_logs::encrypt::aes128::derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256,\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    oracle::{\n        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n        random::random,\n    },\n    utils::{bytes::{be_bytes_31_to_fields, get_random_bytes}, point::get_sign_of_point},\n};\nuse dep::protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n};\nuse std::aes128::aes128_encrypt;\n\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 48; // contract_address (32) + ciphertext_length (2) + 16 bytes pkcs#7 AES padding.\n\n/*\n * WHY IS THERE LOTS OF CODE DUPLICATION BETWEEN event.nr and note.nr?\n * It's because there are a few more optimisations that can be done for notes,\n * and so the stuff that looks like duplicated code currently, won't be\n * the same for long.\n * To modularise now feels premature, because we might get that modularisation wrong.\n * Much better (imo) to have a flattened templates for log assembly, because it\n * makes it much easier for us all to follow, it serves as a nice example for the\n * community to follow (if they wish to roll their own log layouts), and it gives\n * us more time to spot common patterns across all kinds of log layouts.\n */\n\n/*\n * LOG CONFIGURATION CHOICES:\n *\n * deliver_to: INPUT as recipient: AztecAddress\n * encrypt_with: aes128 CBC (Cipher Block Chaining)\n * shared_secret: ephemeral\n * shared_secret_randomness_extraction_hash: sha256\n * tag: true\n * tag_from: INPUT as sender: AztecAddress\n *\n * Note-specific:\n * derive_note_randomness_from_shared_secret: false\n *\n */\n\n/*\n * LOG LAYOUT CHOICE:\n *\n * Short explanation:\n * log = [tag, epk, header_ct=[[contract_address, ct_len], pkcs7_pad], ct=[[pt], pkcs7_pad], some bytes padding, some fields padding]\n *\n * Long explanation:\n * tag: Field\n * epk: [Field, u8]\n * header_ct: [[u8; 32], [u8; 2], [u8; 16]]\n * ct: [[u8; 2], [u8; x], [u8; y]]\n *\n * More precisely (in pseudocode):\n *\n * log = [\n *     tag: Field,\n *     Epk: Field,\n *\n *     le_bytes_31_to_fields(\n *\n *         log_bytes: [\n *             eph_pk_sign: [u8; 1],\n *\n *             header_ciphertext: aes_encrypt(\n *                 contract_address: [u8; 32],\n *                 ct_length: [u8; 2],\n *\n *                 // the aes128_encrypt fn automatically inserts padding:\n *                 header_pt_aes_padding: [u8; 14], // `16 - (input.len() % 16)`\n\n *             ): [u8; 48],\n *\n *             ciphertext: aes_encrypt(\n *                 final_pt: [\n *                     pt: {\n *                         note_bytes: {\n *                             storage_slot: [u8; 32],\n *                             note_type_id: [u8; 32],\n *                             ...note: [u8; N * 32],\n *                         }: [u8; N * 32 + 64],\n *                     }: [u8; N * 32 + 64],\n\n *                 ]: [u8; N * 32 + 64],\n *\n *                 // the aes128_encrypt fn automatically inserts padding:\n *                 pt_aes_padding: [u8; 16 - ( (|pt_length| + |pt|) % 16 )]\n *\n *             ): [u8; |pt| + |pt_aes_padding|]\n *                [u8; |ct|]\n *\n *             log_bytes_padding_to_mult_31: [u8; 31 * ceil((1 + 48 + |ct|)/31) - (1 + 48 + |ct|)],\n *                                           [u8; p]\n *\n *         ]: [u8; 1 + 48 + |ct| + p]\n *\n *     ): [Field; (1 + 48 + |ct| + p) / 31]\n *\n *     log_fields_padding: [Field; PRIVATE_LOG_SIZE_IN_FIELDS - 2 - (1 + 48 + |ct| + p) / 31],\n *\n * ]: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\n *\n *\n */\n\n/********************************************************/\n// Disgusting arithmetic on generics\n/********************************************************/\n\n// In this section, instead of initialising arrays with very complicated generic\n// arithmetic, such as:\n// let my_arr: [u8; (((PT + (16 - (PT % 16))) + 49) + ((((((PT + (16 - (PT % 16))) + 49) + 30) / 31) * 31) - ((PT + (16 - (PT % 16))) + 49)))] = [0; (((PT + (16 - (PT % 16))) + 49) + ((((((PT + (16 - (PT % 16))) + 49) + 30) / 31) * 31) - ((PT + (16 - (PT % 16))) + 49)))];\n//... we instead do the arithmetic a little bit at a time, so that the computation\n// can be audited and understood. Now, we can't do arithmetic on generics in the body\n// of a function, so we abusing functions in the following way:\n\n// |full_pt| = |pt| = (N * 32) + 64\nfn get_arr_of_size__full_plaintext<let PT: u32>() -> [u8; PT] {\n    [0; PT]\n}\n\n// |pt_aes_padding| = 16 - (|full_pt| % 16)\nfn get_arr_of_size__plaintext_aes_padding<let FULL_PT: u32>(\n    _full_pt: [u8; FULL_PT],\n) -> [u8; 16 - (FULL_PT % 16)] {\n    [0; 16 - (FULL_PT % 16)]\n}\n\n// |ct| = |full_pt| + |pt_aes_padding|\nfn get_arr_of_size__ciphertext<let FULL_PT: u32, let PT_AES_PADDING: u32>(\n    _full_pt: [u8; FULL_PT],\n    _pt_aes_padding: [u8; PT_AES_PADDING],\n) -> [u8; FULL_PT + PT_AES_PADDING] {\n    [0; FULL_PT + PT_AES_PADDING]\n}\n\n// Ok, so we have the following bytes:\n// eph_pk_sign, header_ciphertext, ciphertext:\n// Let lbwop = 1 + 48 + |ct| // aka log bytes without padding\nfn get_arr_of_size__log_bytes_without_padding<let CT: u32>(_ct: [u8; CT]) -> [u8; 1 + 48 + CT] {\n    [0; 1 + 48 + CT]\n}\n\n// Recall:\n//   lbwop := 1 + 48 + |ct| // aka log bytes without padding\n// We now want to pad b to the next multiple of 31, so as to \"fill\" fields.\n// Let p be that padding.\n// p = 31 * ceil(lbwop / 31) - lbwop\n//   = 31 * ((lbwop + 30) // 31) - lbwop\n//     (because ceil(x / y) = (x + y - 1) // y ).\nfn get_arr_of_size__log_bytes_padding<let LBWOP: u32>(\n    _lbwop: [u8; LBWOP],\n) -> [u8; (31 * ((LBWOP + 30) / 31)) - LBWOP] {\n    [0; (31 * ((LBWOP + 30) / 31)) - LBWOP]\n}\n\n// |log_bytes| = 1 + 48 + |ct| + p // aka log bytes (with padding)\n// Recall:\n//   lbwop := 1 + 48 + |ct|\n//   p is the padding\nfn get_arr_of_size__log_bytes<let LBWOP: u32, let P: u32>(\n    _lbwop: [u8; LBWOP],\n    _p: [u8; P],\n) -> [u8; LBWOP + P] {\n    [0; LBWOP + P]\n}\n\n// The return type is pasted from the LSP's expectation, because it was too difficult\n// to match its weird way of doing algebra. It doesn't know all rules of arithmetic.\n// PT is the plaintext length.\npub(crate) fn get_arr_of_size__log_bytes_padding__from_PT<let PT: u32>() -> [u8; ((((((PT + (16 - (PT % 16))) + 49) + 30) / 31) * 31) - ((PT + (16 - (PT % 16))) + 49))] {\n    let full_pt = get_arr_of_size__full_plaintext::<PT>();\n    let pt_aes_padding = get_arr_of_size__plaintext_aes_padding(full_pt);\n    let ct = get_arr_of_size__ciphertext(full_pt, pt_aes_padding);\n    let lbwop = get_arr_of_size__log_bytes_without_padding(ct);\n    let p = get_arr_of_size__log_bytes_padding(lbwop);\n    p\n}\n\n// The return type is pasted from the LSP's expectation, because it was too difficult\n// to match its weird way of doing algebra. It doesn't know all rules of arithmetic.\npub(crate) fn get_arr_of_size__log_bytes__from_PT<let PT: u32>() -> [u8; (((PT + (16 - (PT % 16))) + 49) + ((((((PT + (16 - (PT % 16))) + 49) + 30) / 31) * 31) - ((PT + (16 - (PT % 16))) + 49)))] {\n    let full_pt = get_arr_of_size__full_plaintext::<PT>();\n    let pt_aes_padding = get_arr_of_size__plaintext_aes_padding(full_pt);\n    let ct = get_arr_of_size__ciphertext(full_pt, pt_aes_padding);\n    let lbwop = get_arr_of_size__log_bytes_without_padding(ct);\n    let p = get_arr_of_size__log_bytes_padding(lbwop);\n    let log_bytes = get_arr_of_size__log_bytes(lbwop, p);\n    log_bytes\n}\n\n/********************************************************/\n// End of disgusting arithmetic on generics\n/********************************************************/\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists<Note, let N: u32>(context: PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N>,\n{\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\n/// This particular log assembly strategy (AES 128) requires the note (and the\n/// note_id and the storage_slot) to be converted into bytes, because the aes function\n/// operates on bytes; not fields.\n/// NB: The extra `+ 64` bytes is for the note_id and the storage_slot of the note:\nfn compute_note_plaintext_for_this_strategy<Note, let N: u32>(note: Note) -> [u8; N * 32 + 64]\nwhere\n    Note: NoteInterface<N>,\n{\n    let packed_note = note.pack_content();\n\n    let note_header = note.get_header();\n    let storage_slot = note_header.storage_slot;\n    let storage_slot_bytes: [u8; 32] = storage_slot.to_be_bytes();\n\n    // TODO(#10952): The following can be reduced to 7 bits\n    let note_type_id_bytes: [u8; 32] = Note::get_note_type_id().to_be_bytes();\n\n    // We combine all the bytes into plaintext_bytes:\n    let mut plaintext_bytes: [u8; N * 32 + 64] = [0; N * 32 + 64];\n    for i in 0..32 {\n        plaintext_bytes[i] = storage_slot_bytes[i];\n        plaintext_bytes[32 + i] = note_type_id_bytes[i];\n    }\n\n    for i in 0..packed_note.len() {\n        let bytes: [u8; 32] = packed_note[i].to_be_bytes();\n        for j in 0..32 {\n            plaintext_bytes[64 + i * 32 + j] = bytes[j];\n        }\n    }\n\n    plaintext_bytes\n}\n\nfn compute_log<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteInterface<N>,\n{\n    // *****************************************************************************\n    // Compute the shared secret\n    // *****************************************************************************\n\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n    let ciphertext_shared_secret = derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient); // not to be confused with the tagging shared secret\n\n    // TODO: also use this shared secret for deriving note randomness.\n\n    // *****************************************************************************\n    // Compute the plaintext\n    // *****************************************************************************\n\n    let final_plaintext_bytes = compute_note_plaintext_for_this_strategy(note);\n\n    // *****************************************************************************\n    // Convert the plaintext into whatever format the encryption function expects\n    // *****************************************************************************\n\n    // Already done for this strategy: AES expects bytes.\n\n    // *****************************************************************************\n    // Encrypt the plaintext\n    // *****************************************************************************\n\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    let ciphertext_bytes = aes128_encrypt(final_plaintext_bytes, iv, sym_key);\n\n    // |full_pt| = |pt_length| + |pt|\n    // |pt_aes_padding| = 16 - (|full_pt| % 16)\n    // or... since a % b is the same as a - b * (a // b) (integer division), so:\n    // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n    // |ct| = |full_pt| + |pt_aes_padding|\n    //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n    //      = 16 + 16 * (|full_pt| // 16)\n    //      = 16 * (1 + |full_pt| // 16)\n    assert(ciphertext_bytes.len() == 16 * (1 + ((N * 32) + 64) / 16));\n\n    // *****************************************************************************\n    // Compute the header ciphertext\n    // *****************************************************************************\n\n    let contract_address = context.this_address();\n    let contract_address_bytes = contract_address.to_field().to_be_bytes::<32>();\n\n    let mut header_plaintext: [u8; 32 + 2] = [0; 32 + 2];\n    for i in 0..32 {\n        header_plaintext[i] = contract_address_bytes[i];\n    }\n    let offset = 32;\n    let ciphertext_bytes_length = ciphertext_bytes.len();\n    header_plaintext[offset] = (ciphertext_bytes_length >> 8) as u8;\n    header_plaintext[offset + 1] = ciphertext_bytes_length as u8;\n\n    // TODO: this is insecure and wasteful:\n    // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n    // and again for the proper ciphertext) (at least, I never got the\n    // \"go ahead\" that this would be safe, unfortunately).\n    // \"Wasteful\", because the exact same computation is happening further down.\n    // I'm leaving that 2nd computation where it is, because this 1st computation\n    // will be imminently deleted, when the header logic is deleted.\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n    // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n    // bytes larger than the input in this case.\n    let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n    // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n    assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n    // *****************************************************************************\n    // Prepend / append more bytes of data to the ciphertext, before converting back\n    // to fields.\n    // *****************************************************************************\n\n    let mut log_bytes_padding_to_mult_31 =\n        get_arr_of_size__log_bytes_padding__from_PT::<(N * 32) + 64>();\n    /// Safety: this randomness won't be constrained to be random. It's in the\n    /// interest of the executor of this fn to encrypt with random bytes.\n    log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n    let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<(N * 32) + 64>();\n\n    assert(\n        log_bytes.len() % 31 == 0,\n        \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n    );\n\n    log_bytes[0] = eph_pk_sign_byte;\n    let mut offset = 1;\n    for i in 0..header_ciphertext_bytes.len() {\n        log_bytes[offset + i] = header_ciphertext_bytes[i];\n    }\n    offset += header_ciphertext_bytes.len();\n\n    for i in 0..ciphertext_bytes.len() {\n        log_bytes[offset + i] = ciphertext_bytes[i];\n    }\n    offset += ciphertext_bytes.len();\n\n    for i in 0..log_bytes_padding_to_mult_31.len() {\n        log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n    }\n\n    assert(\n        offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n        \"Something has gone wrong\",\n    );\n\n    // *****************************************************************************\n    // Convert bytes back to fields\n    // *****************************************************************************\n\n    let log_bytes_as_fields = be_bytes_31_to_fields(log_bytes);\n\n    // *****************************************************************************\n    // Prepend / append fields, to create the final log\n    // *****************************************************************************\n\n    // In this strategy, we prepend [tag, eph_pk.x]\n\n    // We assume that the sender wants for the recipient to find the tagged note,\n    // and therefore that they will cooperate and use the correct tag. Usage of a bad\n    // tag will result in the recipient not being able to find the note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut final_log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS] = [0; PRIVATE_LOG_SIZE_IN_FIELDS];\n\n    final_log[0] = tag;\n    final_log[1] = eph_pk.x;\n\n    let mut offset = 2;\n    for i in 0..log_bytes_as_fields.len() {\n        final_log[offset + i] = log_bytes_as_fields[i];\n    }\n    offset += log_bytes_as_fields.len();\n\n    for i in offset..PRIVATE_LOG_SIZE_IN_FIELDS {\n        /// Safety: randomness cannot be constrained.\n        final_log[i] = unsafe { random() };\n    }\n\n    final_log\n}\n\nunconstrained fn compute_log_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteInterface<N>,\n{\n    compute_log(context, note, recipient, sender)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        assert_note_exists(*context, note);\n\n        let note_hash_counter = note.get_header().note_hash_counter;\n\n        let encrypted_log = compute_log(*context, note, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\n// Important note: this function -- although called \"unconstrained\" -- the\n// function is not labelled as `unconstrained`, because we pass a reference to the\n// context.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        assert_note_exists(*context, note);\n\n        let note_hash_counter = note.get_header().note_hash_counter;\n\n        //   Unconstrained logs have both their content and encryption unconstrained - it could occur that the\n        // recipient is unable to decrypt the payload.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        //   It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        let encrypted_log = unsafe { compute_log_unconstrained(*context, note, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\nmod test {\n    use crate::test::{helpers::test_environment::TestEnvironment, mocks::mock_note::MockNote};\n    use dep::protocol_types::address::AztecAddress;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n        let mut context = env.private();\n\n        // I'm not sure how to initialise an `env` or `context` with a consistent contract address for every run of this test; the value kept changing each time. So I'm going to overwrite it now:\n        context.inputs.call_context.contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        ); // This is an address copied to match the typescript one.\n\n        let storage_slot = 42;\n        let note = MockNote::new(1234)\n            .contract_address(context.this_address())\n            .storage_slot(storage_slot)\n            .build();\n        let contract_address = context.this_address();\n\n        // All the values in this test were copied over from `encrypted_log_payload.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n\n        let plaintext = super::compute_note_plaintext_for_this_strategy(note);\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let sender = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns([69420, 1337]);\n\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let payload = super::compute_log(context, note, recipient, sender);\n\n        // The following value was generated by `encrypted_log_payload.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let private_log_payload_from_typescript = [\n            0x0e9cffc3ddd746affb02410d8f0a823e89939785bcc8e88ee4f3cae05e737c36,\n            0x0d460c0e434d846ec1ea286e4090eb56376ff27bddc1aacae1d856549f701fa7,\n            0x00010577790aeabcc2d81ec8d0c99e7f5d2bf2f1452025dc777a178404f851d9,\n            0x003de81cde78411f27a921e16ebbfba71a5570d3f62f1134c90daced33663ba0,\n            0x00856cb19c7d563da183a40a6f8bd4988d1696ad6bf0c717c8fb8f6294bd0366,\n            0x001ed04e4f77a111c7090fcd34c61cfae744e8589a42defba4d0d927dd4679fe,\n            0x00ec09b49d8d4cf548ea62d44c8839b2fd14664e9d1439b199a8d5166e362348,\n            0x004a69de2d410e01010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n        ];\n\n        assert_eq(payload, private_log_payload_from_typescript);\n    }\n}\n"
    },
    "94": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.73.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/log_assembly_strategies/default_aes128/partial_note.nr",
      "source": "// THIS FILE WILL GO AWAY WHEN WE REFACTOR PARTIAL NOTES, SO I DON'T FEEL TOO\n// GUILTY ABOUT THE OBVIOUS CODE DUPLICATION VS note.nr & event.nr.\n\nuse crate::{\n    encrypted_logs::{\n        encrypt::aes128::derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256,\n        log_assembly_strategies::default_aes128::note::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n        },\n    },\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    utils::{bytes::{be_bytes_31_to_fields, get_random_bytes}, point::get_sign_of_point},\n};\nuse dep::protocol_types::{address::{aztec_address::ToField, AztecAddress}, hash::poseidon2_hash};\nuse std::aes128::aes128_encrypt;\n\npub fn compute_partial_public_log_payload<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    plaintext: [u8; N],\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; M] {\n    // *****************************************************************************\n    // Compute the shared secret\n    // *****************************************************************************\n\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n    let ciphertext_shared_secret = derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient); // not to be confused with the tagging shared secret\n\n    // TODO: also use this shared secret for deriving note randomness.\n\n    // *****************************************************************************\n    // Prepend/append extra bytes\n    // *****************************************************************************\n\n    // \"Proper\" meaning the main meaty stuff that we care about.\n    let proper_plaintext: [u8; N] = plaintext;\n    let final_plaintext = proper_plaintext;\n\n    // *****************************************************************************\n    // Convert the plaintext into whatever format the encryption function expects\n    // *****************************************************************************\n\n    // Already done for this strategy: AES expects bytes.\n\n    // *****************************************************************************\n    // Encrypt\n    // *****************************************************************************\n\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    let ciphertext_bytes = aes128_encrypt(final_plaintext, iv, sym_key);\n\n    assert(ciphertext_bytes.len() == 16 * (1 + (2 + N) / 16));\n\n    // *****************************************************************************\n    // Compute the header ciphertext\n    // *****************************************************************************\n\n    let contract_address_bytes = contract_address.to_field().to_be_bytes::<32>();\n\n    let mut header_plaintext: [u8; 32 + 2] = [0; 32 + 2];\n    for i in 0..32 {\n        header_plaintext[i] = contract_address_bytes[i];\n    }\n    let offset = contract_address_bytes.len();\n\n    let ciphertext_bytes_length = ciphertext_bytes.len();\n    header_plaintext[offset] = (ciphertext_bytes_length >> 8) as u8;\n    header_plaintext[offset + 1] = ciphertext_bytes_length as u8;\n\n    // TODO: this is insecure and wasteful:\n    // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n    // and again for the proper ciphertext) (at least, I never got the\n    // \"go ahead\" that this would be safe, unfortunately).\n    // \"Wasteful\", because the exact same computation is happening further down.\n    // I'm leaving that 2nd computation where it is, because this 1st computation\n    // will be imminently deleted, when the header logic is deleted.\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n    // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n    // bytes larger than the input in this case.\n    let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n    // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n    assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n    // *****************************************************************************\n    // Prepend / append more bytes of data to the ciphertext, before converting back\n    // to fields.\n    // *****************************************************************************\n\n    let mut log_bytes_padding_to_mult_31 = get_arr_of_size__log_bytes_padding__from_PT::<2 + N>();\n    log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n    let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<2 + N>();\n\n    log_bytes[0] = eph_pk_sign_byte;\n    let mut offset = 1;\n    for i in 0..header_ciphertext_bytes.len() {\n        log_bytes[offset + i] = header_ciphertext_bytes[i];\n    }\n    offset += header_ciphertext_bytes.len();\n\n    for i in 0..ciphertext_bytes.len() {\n        log_bytes[offset + i] = ciphertext_bytes[i];\n    }\n    offset += ciphertext_bytes.len();\n\n    for i in 0..log_bytes_padding_to_mult_31.len() {\n        log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n    }\n\n    // *****************************************************************************\n    // Convert bytes back to fields\n    // *****************************************************************************\n\n    let log_bytes_as_fields = be_bytes_31_to_fields(log_bytes);\n\n    // *****************************************************************************\n    // Prepend / append fields, to create the final log\n    // *****************************************************************************\n\n    // We don't add any extra random padding.\n    // Whilst we do this in note.nr, we won't do it for this partial_note log, because it's going to get stored in public, and so:\n    // - The nature of the tx is going to be leaked.\n    // - We therefore don't care if it's padded to obscure the length of the actual ciphertext.\n    // Note: partial logs are going to be greatly refactored, soon.\n\n    // We assume that the sender wants for the recipient to find the tagged note, and therefore that they will cooperate\n    // and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the note\n    // automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    // Silo the tag with contract address.\n    // This is done by the kernel circuit to the private logs, but since the partial log will be finalized and emitted\n    // in public as unencrypted log, its tag is not siloed at the moment.\n    // To avoid querying logs using two types of tags, we silo the tag manually here.\n    // TODO(#10273) This should be done by the AVM when it's processing the raw logs instead of their hashes.\n    let siloed_tag = poseidon2_hash([contract_address.to_field(), tag]);\n\n    // Temporary hack so that the partial public log remains the same format.\n    // It should return field array and make the tag the first field as compute_private_log_payload does.\n\n    let mut final_log: [Field; M] = [0; M];\n\n    final_log[0] = siloed_tag;\n    final_log[1] = eph_pk.x;\n\n    let mut offset = 2;\n    for i in 0..log_bytes_as_fields.len() {\n        final_log[offset + i] = log_bytes_as_fields[i];\n    }\n\n    final_log\n}\n"
    }
  }
}
